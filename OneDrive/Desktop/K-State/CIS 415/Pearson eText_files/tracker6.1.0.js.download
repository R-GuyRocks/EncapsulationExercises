/* Tracker SDK 6.1.0 */
 (function() {
/*
Author: Geraint Luff and others
Year: 2013

This code is released into the "public domain" by its author(s).  Anybody may use, alter and distribute the code without restriction.  The author makes no guarantees, and takes no liability of any kind for use of this code.

If you find a bug or make an improvement, it would be courteous to let the author know, but it is not compulsory.
*/
(function (global, factory) {
  if (typeof define === 'function' && define.amd) {
    // AMD. Register as an anonymous module.
    global.tv4 = factory();
  } else if (typeof module !== 'undefined' && module.exports){
    // CommonJS. Define export.
    module.exports = factory();
  } else {
    // Browser globals
    global.tv4 = factory();
  }
}(this, function () {

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FObject%2Fkeys
if (!Object.keys) {
	Object.keys = (function () {
		var hasOwnProperty = Object.prototype.hasOwnProperty,
			hasDontEnumBug = !({toString: null}).propertyIsEnumerable('toString'),
			dontEnums = [
				'toString',
				'toLocaleString',
				'valueOf',
				'hasOwnProperty',
				'isPrototypeOf',
				'propertyIsEnumerable',
				'constructor'
			],
			dontEnumsLength = dontEnums.length;

		return function (obj) {
			if (typeof obj !== 'object' && typeof obj !== 'function' || obj === null) {
				throw new TypeError('Object.keys called on non-object');
			}

			var result = [];

			for (var prop in obj) {
				if (hasOwnProperty.call(obj, prop)) {
					result.push(prop);
				}
			}

			if (hasDontEnumBug) {
				for (var i=0; i < dontEnumsLength; i++) {
					if (hasOwnProperty.call(obj, dontEnums[i])) {
						result.push(dontEnums[i]);
					}
				}
			}
			return result;
		};
	})();
}
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create
if (!Object.create) {
	Object.create = (function(){
		function F(){}

		return function(o){
			if (arguments.length !== 1) {
				throw new Error('Object.create implementation only accepts one parameter.');
			}
			F.prototype = o;
			return new F();
		};
	})();
}
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FArray%2FisArray
if(!Array.isArray) {
	Array.isArray = function (vArg) {
		return Object.prototype.toString.call(vArg) === "[object Array]";
	};
}
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FArray%2FindexOf
if (!Array.prototype.indexOf) {
	Array.prototype.indexOf = function (searchElement /*, fromIndex */ ) {
		if (this === null) {
			throw new TypeError();
		}
		var t = Object(this);
		var len = t.length >>> 0;

		if (len === 0) {
			return -1;
		}
		var n = 0;
		if (arguments.length > 1) {
			n = Number(arguments[1]);
			if (n !== n) { // shortcut for verifying if it's NaN
				n = 0;
			} else if (n !== 0 && n !== Infinity && n !== -Infinity) {
				n = (n > 0 || -1) * Math.floor(Math.abs(n));
			}
		}
		if (n >= len) {
			return -1;
		}
		var k = n >= 0 ? n : Math.max(len - Math.abs(n), 0);
		for (; k < len; k++) {
			if (k in t && t[k] === searchElement) {
				return k;
			}
		}
		return -1;
	};
}

// Grungey Object.isFrozen hack
if (!Object.isFrozen) {
	Object.isFrozen = function (obj) {
		var key = "tv4_test_frozen_key";
		while (obj.hasOwnProperty(key)) {
			key += Math.random();
		}
		try {
			obj[key] = true;
			delete obj[key];
			return false;
		} catch (e) {
			return true;
		}
	};
}
// Based on: https://github.com/geraintluff/uri-templates, but with all the de-substitution stuff removed

var uriTemplateGlobalModifiers = {
	"+": true,
	"#": true,
	".": true,
	"/": true,
	";": true,
	"?": true,
	"&": true
};
var uriTemplateSuffices = {
	"*": true
};

function notReallyPercentEncode(string) {
	return encodeURI(string).replace(/%25[0-9][0-9]/g, function (doubleEncoded) {
		return "%" + doubleEncoded.substring(3);
	});
}

function uriTemplateSubstitution(spec) {
	var modifier = "";
	if (uriTemplateGlobalModifiers[spec.charAt(0)]) {
		modifier = spec.charAt(0);
		spec = spec.substring(1);
	}
	var separator = "";
	var prefix = "";
	var shouldEscape = true;
	var showVariables = false;
	var trimEmptyString = false;
	if (modifier === '+') {
		shouldEscape = false;
	} else if (modifier === ".") {
		prefix = ".";
		separator = ".";
	} else if (modifier === "/") {
		prefix = "/";
		separator = "/";
	} else if (modifier === '#') {
		prefix = "#";
		shouldEscape = false;
	} else if (modifier === ';') {
		prefix = ";";
		separator = ";";
		showVariables = true;
		trimEmptyString = true;
	} else if (modifier === '?') {
		prefix = "?";
		separator = "&";
		showVariables = true;
	} else if (modifier === '&') {
		prefix = "&";
		separator = "&";
		showVariables = true;
	}

	var varNames = [];
	var varList = spec.split(",");
	var varSpecs = [];
	var varSpecMap = {};
	for (var i = 0; i < varList.length; i++) {
		var varName = varList[i];
		var truncate = null;
		if (varName.indexOf(":") !== -1) {
			var parts = varName.split(":");
			varName = parts[0];
			truncate = parseInt(parts[1], 10);
		}
		var suffices = {};
		while (uriTemplateSuffices[varName.charAt(varName.length - 1)]) {
			suffices[varName.charAt(varName.length - 1)] = true;
			varName = varName.substring(0, varName.length - 1);
		}
		var varSpec = {
			truncate: truncate,
			name: varName,
			suffices: suffices
		};
		varSpecs.push(varSpec);
		varSpecMap[varName] = varSpec;
		varNames.push(varName);
	}
	var subFunction = function (valueFunction) {
		var result = "";
		var startIndex = 0;
		for (var i = 0; i < varSpecs.length; i++) {
			var varSpec = varSpecs[i];
			var value = valueFunction(varSpec.name);
			if (value === null || value === undefined || (Array.isArray(value) && value.length === 0) || (typeof value === 'object' && Object.keys(value).length === 0)) {
				startIndex++;
				continue;
			}
			if (i === startIndex) {
				result += prefix;
			} else {
				result += (separator || ",");
			}
			if (Array.isArray(value)) {
				if (showVariables) {
					result += varSpec.name + "=";
				}
				for (var j = 0; j < value.length; j++) {
					if (j > 0) {
						result += varSpec.suffices['*'] ? (separator || ",") : ",";
						if (varSpec.suffices['*'] && showVariables) {
							result += varSpec.name + "=";
						}
					}
					result += shouldEscape ? encodeURIComponent(value[j]).replace(/!/g, "%21") : notReallyPercentEncode(value[j]);
				}
			} else if (typeof value === "object") {
				if (showVariables && !varSpec.suffices['*']) {
					result += varSpec.name + "=";
				}
				var first = true;
				for (var key in value) {
					if (!first) {
						result += varSpec.suffices['*'] ? (separator || ",") : ",";
					}
					first = false;
					result += shouldEscape ? encodeURIComponent(key).replace(/!/g, "%21") : notReallyPercentEncode(key);
					result += varSpec.suffices['*'] ? '=' : ",";
					result += shouldEscape ? encodeURIComponent(value[key]).replace(/!/g, "%21") : notReallyPercentEncode(value[key]);
				}
			} else {
				if (showVariables) {
					result += varSpec.name;
					if (!trimEmptyString || value !== "") {
						result += "=";
					}
				}
				if (varSpec.truncate != null) {
					value = value.substring(0, varSpec.truncate);
				}
				result += shouldEscape ? encodeURIComponent(value).replace(/!/g, "%21"): notReallyPercentEncode(value);
			}
		}
		return result;
	};
	subFunction.varNames = varNames;
	return {
		prefix: prefix,
		substitution: subFunction
	};
}

function UriTemplate(template) {
	if (!(this instanceof UriTemplate)) {
		return new UriTemplate(template);
	}
	var parts = template.split("{");
	var textParts = [parts.shift()];
	var prefixes = [];
	var substitutions = [];
	var varNames = [];
	while (parts.length > 0) {
		var part = parts.shift();
		var spec = part.split("}")[0];
		var remainder = part.substring(spec.length + 1);
		var funcs = uriTemplateSubstitution(spec);
		substitutions.push(funcs.substitution);
		prefixes.push(funcs.prefix);
		textParts.push(remainder);
		varNames = varNames.concat(funcs.substitution.varNames);
	}
	this.fill = function (valueFunction) {
		var result = textParts[0];
		for (var i = 0; i < substitutions.length; i++) {
			var substitution = substitutions[i];
			result += substitution(valueFunction);
			result += textParts[i + 1];
		}
		return result;
	};
	this.varNames = varNames;
	this.template = template;
}
UriTemplate.prototype = {
	toString: function () {
		return this.template;
	},
	fillFromObject: function (obj) {
		return this.fill(function (varName) {
			return obj[varName];
		});
	}
};
var ValidatorContext = function ValidatorContext(parent, collectMultiple, errorReporter, checkRecursive, trackUnknownProperties) {
	this.missing = [];
	this.missingMap = {};
	this.formatValidators = parent ? Object.create(parent.formatValidators) : {};
	this.schemas = parent ? Object.create(parent.schemas) : {};
	this.collectMultiple = collectMultiple;
	this.errors = [];
	this.handleError = collectMultiple ? this.collectError : this.returnError;
	if (checkRecursive) {
		this.checkRecursive = true;
		this.scanned = [];
		this.scannedFrozen = [];
		this.scannedFrozenSchemas = [];
		this.scannedFrozenValidationErrors = [];
		this.validatedSchemasKey = 'tv4_validation_id';
		this.validationErrorsKey = 'tv4_validation_errors_id';
	}
	if (trackUnknownProperties) {
		this.trackUnknownProperties = true;
		this.knownPropertyPaths = {};
		this.unknownPropertyPaths = {};
	}
	this.errorReporter = errorReporter || defaultErrorReporter('en');
	if (typeof this.errorReporter === 'string') {
		throw new Error('debug');
	}
	this.definedKeywords = {};
	if (parent) {
		for (var key in parent.definedKeywords) {
			this.definedKeywords[key] = parent.definedKeywords[key].slice(0);
		}
	}
};
ValidatorContext.prototype.defineKeyword = function (keyword, keywordFunction) {
	this.definedKeywords[keyword] = this.definedKeywords[keyword] || [];
	this.definedKeywords[keyword].push(keywordFunction);
};
ValidatorContext.prototype.createError = function (code, messageParams, dataPath, schemaPath, subErrors, data, schema) {
	var error = new ValidationError(code, messageParams, dataPath, schemaPath, subErrors);
	error.message = this.errorReporter(error, data, schema);
	return error;
};
ValidatorContext.prototype.returnError = function (error) {
	return error;
};
ValidatorContext.prototype.collectError = function (error) {
	if (error) {
		this.errors.push(error);
	}
	return null;
};
ValidatorContext.prototype.prefixErrors = function (startIndex, dataPath, schemaPath) {
	for (var i = startIndex; i < this.errors.length; i++) {
		this.errors[i] = this.errors[i].prefixWith(dataPath, schemaPath);
	}
	return this;
};
ValidatorContext.prototype.banUnknownProperties = function (data, schema) {
	for (var unknownPath in this.unknownPropertyPaths) {
		var error = this.createError(ErrorCodes.UNKNOWN_PROPERTY, {path: unknownPath}, unknownPath, "", null, data, schema);
		var result = this.handleError(error);
		if (result) {
			return result;
		}
	}
	return null;
};

ValidatorContext.prototype.addFormat = function (format, validator) {
	if (typeof format === 'object') {
		for (var key in format) {
			this.addFormat(key, format[key]);
		}
		return this;
	}
	this.formatValidators[format] = validator;
};
ValidatorContext.prototype.resolveRefs = function (schema, urlHistory) {
	if (schema['$ref'] !== undefined) {
		urlHistory = urlHistory || {};
		if (urlHistory[schema['$ref']]) {
			return this.createError(ErrorCodes.CIRCULAR_REFERENCE, {urls: Object.keys(urlHistory).join(', ')}, '', '', null, undefined, schema);
		}
		urlHistory[schema['$ref']] = true;
		schema = this.getSchema(schema['$ref'], urlHistory);
	}
	return schema;
};
ValidatorContext.prototype.getSchema = function (url, urlHistory) {
	var schema;
	if (this.schemas[url] !== undefined) {
		schema = this.schemas[url];
		return this.resolveRefs(schema, urlHistory);
	}
	var baseUrl = url;
	var fragment = "";
	if (url.indexOf('#') !== -1) {
		fragment = url.substring(url.indexOf("#") + 1);
		baseUrl = url.substring(0, url.indexOf("#"));
	}
	if (typeof this.schemas[baseUrl] === 'object') {
		schema = this.schemas[baseUrl];
		var pointerPath = decodeURIComponent(fragment);
		if (pointerPath === "") {
			return this.resolveRefs(schema, urlHistory);
		} else if (pointerPath.charAt(0) !== "/") {
			return undefined;
		}
		var parts = pointerPath.split("/").slice(1);
		for (var i = 0; i < parts.length; i++) {
			var component = parts[i].replace(/~1/g, "/").replace(/~0/g, "~");
			if (schema[component] === undefined) {
				schema = undefined;
				break;
			}
			schema = schema[component];
		}
		if (schema !== undefined) {
			return this.resolveRefs(schema, urlHistory);
		}
	}
	if (this.missing[baseUrl] === undefined) {
		this.missing.push(baseUrl);
		this.missing[baseUrl] = baseUrl;
		this.missingMap[baseUrl] = baseUrl;
	}
};
ValidatorContext.prototype.searchSchemas = function (schema, url) {
	if (Array.isArray(schema)) {
		for (var i = 0; i < schema.length; i++) {
			this.searchSchemas(schema[i], url);
		}
	} else if (schema && typeof schema === "object") {
		if (typeof schema.id === "string") {
			if (isTrustedUrl(url, schema.id)) {
				if (this.schemas[schema.id] === undefined) {
					this.schemas[schema.id] = schema;
				}
			}
		}
		for (var key in schema) {
			if (key !== "enum") {
				if (typeof schema[key] === "object") {
					this.searchSchemas(schema[key], url);
				} else if (key === "$ref") {
					var uri = getDocumentUri(schema[key]);
					if (uri && this.schemas[uri] === undefined && this.missingMap[uri] === undefined) {
						this.missingMap[uri] = uri;
					}
				}
			}
		}
	}
};
ValidatorContext.prototype.addSchema = function (url, schema) {
	//overload
	if (typeof url !== 'string' || typeof schema === 'undefined') {
		if (typeof url === 'object' && typeof url.id === 'string') {
			schema = url;
			url = schema.id;
		}
		else {
			return;
		}
	}
	if (url === getDocumentUri(url) + "#") {
		// Remove empty fragment
		url = getDocumentUri(url);
	}
	this.schemas[url] = schema;
	delete this.missingMap[url];
	normSchema(schema, url);
	this.searchSchemas(schema, url);
};

ValidatorContext.prototype.getSchemaMap = function () {
	var map = {};
	for (var key in this.schemas) {
		map[key] = this.schemas[key];
	}
	return map;
};

ValidatorContext.prototype.getSchemaUris = function (filterRegExp) {
	var list = [];
	for (var key in this.schemas) {
		if (!filterRegExp || filterRegExp.test(key)) {
			list.push(key);
		}
	}
	return list;
};

ValidatorContext.prototype.getMissingUris = function (filterRegExp) {
	var list = [];
	for (var key in this.missingMap) {
		if (!filterRegExp || filterRegExp.test(key)) {
			list.push(key);
		}
	}
	return list;
};

ValidatorContext.prototype.dropSchemas = function () {
	this.schemas = {};
	this.reset();
};
ValidatorContext.prototype.reset = function () {
	this.missing = [];
	this.missingMap = {};
	this.errors = [];
};

ValidatorContext.prototype.validateAll = function (data, schema, dataPathParts, schemaPathParts, dataPointerPath) {
	var topLevel;
	schema = this.resolveRefs(schema);
	if (!schema) {
		return null;
	} else if (schema instanceof ValidationError) {
		this.errors.push(schema);
		return schema;
	}

	var startErrorCount = this.errors.length;
	var frozenIndex, scannedFrozenSchemaIndex = null, scannedSchemasIndex = null;
	if (this.checkRecursive && data && typeof data === 'object') {
		topLevel = !this.scanned.length;
		if (data[this.validatedSchemasKey]) {
			var schemaIndex = data[this.validatedSchemasKey].indexOf(schema);
			if (schemaIndex !== -1) {
				this.errors = this.errors.concat(data[this.validationErrorsKey][schemaIndex]);
				return null;
			}
		}
		if (Object.isFrozen(data)) {
			frozenIndex = this.scannedFrozen.indexOf(data);
			if (frozenIndex !== -1) {
				var frozenSchemaIndex = this.scannedFrozenSchemas[frozenIndex].indexOf(schema);
				if (frozenSchemaIndex !== -1) {
					this.errors = this.errors.concat(this.scannedFrozenValidationErrors[frozenIndex][frozenSchemaIndex]);
					return null;
				}
			}
		}
		this.scanned.push(data);
		if (Object.isFrozen(data)) {
			if (frozenIndex === -1) {
				frozenIndex = this.scannedFrozen.length;
				this.scannedFrozen.push(data);
				this.scannedFrozenSchemas.push([]);
			}
			scannedFrozenSchemaIndex = this.scannedFrozenSchemas[frozenIndex].length;
			this.scannedFrozenSchemas[frozenIndex][scannedFrozenSchemaIndex] = schema;
			this.scannedFrozenValidationErrors[frozenIndex][scannedFrozenSchemaIndex] = [];
		} else {
			if (!data[this.validatedSchemasKey]) {
				try {
					Object.defineProperty(data, this.validatedSchemasKey, {
						value: [],
						configurable: true
					});
					Object.defineProperty(data, this.validationErrorsKey, {
						value: [],
						configurable: true
					});
				} catch (e) {
					//IE 7/8 workaround
					data[this.validatedSchemasKey] = [];
					data[this.validationErrorsKey] = [];
				}
			}
			scannedSchemasIndex = data[this.validatedSchemasKey].length;
			data[this.validatedSchemasKey][scannedSchemasIndex] = schema;
			data[this.validationErrorsKey][scannedSchemasIndex] = [];
		}
	}

	var errorCount = this.errors.length;
	var error = this.validateBasic(data, schema, dataPointerPath)
		|| this.validateNumeric(data, schema, dataPointerPath)
		|| this.validateString(data, schema, dataPointerPath)
		|| this.validateArray(data, schema, dataPointerPath)
		|| this.validateObject(data, schema, dataPointerPath)
		|| this.validateCombinations(data, schema, dataPointerPath)
		|| this.validateHypermedia(data, schema, dataPointerPath)
		|| this.validateFormat(data, schema, dataPointerPath)
		|| this.validateDefinedKeywords(data, schema, dataPointerPath)
		|| null;

	if (topLevel) {
		while (this.scanned.length) {
			var item = this.scanned.pop();
			delete item[this.validatedSchemasKey];
		}
		this.scannedFrozen = [];
		this.scannedFrozenSchemas = [];
	}

	if (error || errorCount !== this.errors.length) {
		while ((dataPathParts && dataPathParts.length) || (schemaPathParts && schemaPathParts.length)) {
			var dataPart = (dataPathParts && dataPathParts.length) ? "" + dataPathParts.pop() : null;
			var schemaPart = (schemaPathParts && schemaPathParts.length) ? "" + schemaPathParts.pop() : null;
			if (error) {
				error = error.prefixWith(dataPart, schemaPart);
			}
			this.prefixErrors(errorCount, dataPart, schemaPart);
		}
	}

	if (scannedFrozenSchemaIndex !== null) {
		this.scannedFrozenValidationErrors[frozenIndex][scannedFrozenSchemaIndex] = this.errors.slice(startErrorCount);
	} else if (scannedSchemasIndex !== null) {
		data[this.validationErrorsKey][scannedSchemasIndex] = this.errors.slice(startErrorCount);
	}

	return this.handleError(error);
};
ValidatorContext.prototype.validateFormat = function (data, schema) {
	if (typeof schema.format !== 'string' || !this.formatValidators[schema.format]) {
		return null;
	}
	var errorMessage = this.formatValidators[schema.format].call(null, data, schema);
	if (typeof errorMessage === 'string' || typeof errorMessage === 'number') {
		return this.createError(ErrorCodes.FORMAT_CUSTOM, {message: errorMessage}, '', '/format', null, data, schema);
	} else if (errorMessage && typeof errorMessage === 'object') {
		return this.createError(ErrorCodes.FORMAT_CUSTOM, {message: errorMessage.message || "?"}, errorMessage.dataPath || '', errorMessage.schemaPath || "/format", null, data, schema);
	}
	return null;
};
ValidatorContext.prototype.validateDefinedKeywords = function (data, schema, dataPointerPath) {
	for (var key in this.definedKeywords) {
		if (typeof schema[key] === 'undefined') {
			continue;
		}
		var validationFunctions = this.definedKeywords[key];
		for (var i = 0; i < validationFunctions.length; i++) {
			var func = validationFunctions[i];
			var result = func(data, schema[key], schema, dataPointerPath);
			if (typeof result === 'string' || typeof result === 'number') {
				return this.createError(ErrorCodes.KEYWORD_CUSTOM, {key: key, message: result}, '', '', null, data, schema).prefixWith(null, key);
			} else if (result && typeof result === 'object') {
				var code = result.code;
				if (typeof code === 'string') {
					if (!ErrorCodes[code]) {
						throw new Error('Undefined error code (use defineError): ' + code);
					}
					code = ErrorCodes[code];
				} else if (typeof code !== 'number') {
					code = ErrorCodes.KEYWORD_CUSTOM;
				}
				var messageParams = (typeof result.message === 'object') ? result.message : {key: key, message: result.message || "?"};
				var schemaPath = result.schemaPath || ("/" + key.replace(/~/g, '~0').replace(/\//g, '~1'));
				return this.createError(code, messageParams, result.dataPath || null, schemaPath, null, data, schema);
			}
		}
	}
	return null;
};

function recursiveCompare(A, B) {
	if (A === B) {
		return true;
	}
	if (A && B && typeof A === "object" && typeof B === "object") {
		if (Array.isArray(A) !== Array.isArray(B)) {
			return false;
		} else if (Array.isArray(A)) {
			if (A.length !== B.length) {
				return false;
			}
			for (var i = 0; i < A.length; i++) {
				if (!recursiveCompare(A[i], B[i])) {
					return false;
				}
			}
		} else {
			var key;
			for (key in A) {
				if (B[key] === undefined && A[key] !== undefined) {
					return false;
				}
			}
			for (key in B) {
				if (A[key] === undefined && B[key] !== undefined) {
					return false;
				}
			}
			for (key in A) {
				if (!recursiveCompare(A[key], B[key])) {
					return false;
				}
			}
		}
		return true;
	}
	return false;
}

ValidatorContext.prototype.validateBasic = function validateBasic(data, schema, dataPointerPath) {
	var error;
	if (error = this.validateType(data, schema, dataPointerPath)) {
		return error.prefixWith(null, "type");
	}
	if (error = this.validateEnum(data, schema, dataPointerPath)) {
		return error.prefixWith(null, "type");
	}
	return null;
};

ValidatorContext.prototype.validateType = function validateType(data, schema) {
	if (schema.type === undefined) {
		return null;
	}
	var dataType = typeof data;
	if (data === null) {
		dataType = "null";
	} else if (Array.isArray(data)) {
		dataType = "array";
	}
	var allowedTypes = schema.type;
	if (!Array.isArray(allowedTypes)) {
		allowedTypes = [allowedTypes];
	}

	for (var i = 0; i < allowedTypes.length; i++) {
		var type = allowedTypes[i];
		if (type === dataType || (type === "integer" && dataType === "number" && (data % 1 === 0))) {
			return null;
		}
	}
	return this.createError(ErrorCodes.INVALID_TYPE, {type: dataType, expected: allowedTypes.join("/")}, '', '', null, data, schema);
};

ValidatorContext.prototype.validateEnum = function validateEnum(data, schema) {
	if (schema["enum"] === undefined) {
		return null;
	}
	for (var i = 0; i < schema["enum"].length; i++) {
		var enumVal = schema["enum"][i];
		if (recursiveCompare(data, enumVal)) {
			return null;
		}
	}
	return this.createError(ErrorCodes.ENUM_MISMATCH, {value: (typeof JSON !== 'undefined') ? JSON.stringify(data) : data}, '', '', null, data, schema);
};

ValidatorContext.prototype.validateNumeric = function validateNumeric(data, schema, dataPointerPath) {
	return this.validateMultipleOf(data, schema, dataPointerPath)
		|| this.validateMinMax(data, schema, dataPointerPath)
		|| this.validateNaN(data, schema, dataPointerPath)
		|| null;
};

var CLOSE_ENOUGH_LOW = Math.pow(2, -51);
var CLOSE_ENOUGH_HIGH = 1 - CLOSE_ENOUGH_LOW;
ValidatorContext.prototype.validateMultipleOf = function validateMultipleOf(data, schema) {
	var multipleOf = schema.multipleOf || schema.divisibleBy;
	if (multipleOf === undefined) {
		return null;
	}
	if (typeof data === "number") {
		var remainder = (data/multipleOf)%1;
		if (remainder >= CLOSE_ENOUGH_LOW && remainder < CLOSE_ENOUGH_HIGH) {
			return this.createError(ErrorCodes.NUMBER_MULTIPLE_OF, {value: data, multipleOf: multipleOf}, '', '', null, data, schema);
		}
	}
	return null;
};

ValidatorContext.prototype.validateMinMax = function validateMinMax(data, schema) {
	if (typeof data !== "number") {
		return null;
	}
	if (schema.minimum !== undefined) {
		if (data < schema.minimum) {
			return this.createError(ErrorCodes.NUMBER_MINIMUM, {value: data, minimum: schema.minimum}, '', '/minimum', null, data, schema);
		}
		if (schema.exclusiveMinimum && data === schema.minimum) {
			return this.createError(ErrorCodes.NUMBER_MINIMUM_EXCLUSIVE, {value: data, minimum: schema.minimum}, '', '/exclusiveMinimum', null, data, schema);
		}
	}
	if (schema.maximum !== undefined) {
		if (data > schema.maximum) {
			return this.createError(ErrorCodes.NUMBER_MAXIMUM, {value: data, maximum: schema.maximum}, '', '/maximum', null, data, schema);
		}
		if (schema.exclusiveMaximum && data === schema.maximum) {
			return this.createError(ErrorCodes.NUMBER_MAXIMUM_EXCLUSIVE, {value: data, maximum: schema.maximum}, '', '/exclusiveMaximum', null, data, schema);
		}
	}
	return null;
};

ValidatorContext.prototype.validateNaN = function validateNaN(data, schema) {
	if (typeof data !== "number") {
		return null;
	}
	if (isNaN(data) === true || data === Infinity || data === -Infinity) {
		return this.createError(ErrorCodes.NUMBER_NOT_A_NUMBER, {value: data}, '', '/type', null, data, schema);
	}
	return null;
};

ValidatorContext.prototype.validateString = function validateString(data, schema, dataPointerPath) {
	return this.validateStringLength(data, schema, dataPointerPath)
		|| this.validateStringPattern(data, schema, dataPointerPath)
		|| null;
};

ValidatorContext.prototype.validateStringLength = function validateStringLength(data, schema) {
	if (typeof data !== "string") {
		return null;
	}
	if (schema.minLength !== undefined) {
		if (data.length < schema.minLength) {
			return this.createError(ErrorCodes.STRING_LENGTH_SHORT, {length: data.length, minimum: schema.minLength}, '', '/minLength', null, data, schema);
		}
	}
	if (schema.maxLength !== undefined) {
		if (data.length > schema.maxLength) {
			return this.createError(ErrorCodes.STRING_LENGTH_LONG, {length: data.length, maximum: schema.maxLength}, '', '/maxLength', null, data, schema);
		}
	}
	return null;
};

ValidatorContext.prototype.validateStringPattern = function validateStringPattern(data, schema) {
	if (typeof data !== "string" || (typeof schema.pattern !== "string" && !(schema.pattern instanceof RegExp))) {
		return null;
	}
	var regexp;
	if (schema.pattern instanceof RegExp) {
	  regexp = schema.pattern;
	}
	else {
	  var body, flags = '';
	  // Check for regular expression literals
	  // @see http://www.ecma-international.org/ecma-262/5.1/#sec-7.8.5
	  var literal = schema.pattern.match(/^\/(.+)\/([img]*)$/);
	  if (literal) {
	    body = literal[1];
	    flags = literal[2];
	  }
	  else {
	    body = schema.pattern;
	  }
	  regexp = new RegExp(body, flags);
	}
	if (!regexp.test(data)) {
		return this.createError(ErrorCodes.STRING_PATTERN, {pattern: schema.pattern}, '', '/pattern', null, data, schema);
	}
	return null;
};

ValidatorContext.prototype.validateArray = function validateArray(data, schema, dataPointerPath) {
	if (!Array.isArray(data)) {
		return null;
	}
	return this.validateArrayLength(data, schema, dataPointerPath)
		|| this.validateArrayUniqueItems(data, schema, dataPointerPath)
		|| this.validateArrayItems(data, schema, dataPointerPath)
		|| null;
};

ValidatorContext.prototype.validateArrayLength = function validateArrayLength(data, schema) {
	var error;
	if (schema.minItems !== undefined) {
		if (data.length < schema.minItems) {
			error = this.createError(ErrorCodes.ARRAY_LENGTH_SHORT, {length: data.length, minimum: schema.minItems}, '', '/minItems', null, data, schema);
			if (this.handleError(error)) {
				return error;
			}
		}
	}
	if (schema.maxItems !== undefined) {
		if (data.length > schema.maxItems) {
			error = this.createError(ErrorCodes.ARRAY_LENGTH_LONG, {length: data.length, maximum: schema.maxItems}, '', '/maxItems', null, data, schema);
			if (this.handleError(error)) {
				return error;
			}
		}
	}
	return null;
};

ValidatorContext.prototype.validateArrayUniqueItems = function validateArrayUniqueItems(data, schema) {
	if (schema.uniqueItems) {
		for (var i = 0; i < data.length; i++) {
			for (var j = i + 1; j < data.length; j++) {
				if (recursiveCompare(data[i], data[j])) {
					var error = this.createError(ErrorCodes.ARRAY_UNIQUE, {match1: i, match2: j}, '', '/uniqueItems', null, data, schema);
					if (this.handleError(error)) {
						return error;
					}
				}
			}
		}
	}
	return null;
};

ValidatorContext.prototype.validateArrayItems = function validateArrayItems(data, schema, dataPointerPath) {
	if (schema.items === undefined) {
		return null;
	}
	var error, i;
	if (Array.isArray(schema.items)) {
		for (i = 0; i < data.length; i++) {
			if (i < schema.items.length) {
				if (error = this.validateAll(data[i], schema.items[i], [i], ["items", i], dataPointerPath + "/" + i)) {
					return error;
				}
			} else if (schema.additionalItems !== undefined) {
				if (typeof schema.additionalItems === "boolean") {
					if (!schema.additionalItems) {
						error = (this.createError(ErrorCodes.ARRAY_ADDITIONAL_ITEMS, {}, '/' + i, '/additionalItems', null, data, schema));
						if (this.handleError(error)) {
							return error;
						}
					}
				} else if (error = this.validateAll(data[i], schema.additionalItems, [i], ["additionalItems"], dataPointerPath + "/" + i)) {
					return error;
				}
			}
		}
	} else {
		for (i = 0; i < data.length; i++) {
			if (error = this.validateAll(data[i], schema.items, [i], ["items"], dataPointerPath + "/" + i)) {
				return error;
			}
		}
	}
	return null;
};

ValidatorContext.prototype.validateObject = function validateObject(data, schema, dataPointerPath) {
	if (typeof data !== "object" || data === null || Array.isArray(data)) {
		return null;
	}
	return this.validateObjectMinMaxProperties(data, schema, dataPointerPath)
		|| this.validateObjectRequiredProperties(data, schema, dataPointerPath)
		|| this.validateObjectProperties(data, schema, dataPointerPath)
		|| this.validateObjectDependencies(data, schema, dataPointerPath)
		|| null;
};

ValidatorContext.prototype.validateObjectMinMaxProperties = function validateObjectMinMaxProperties(data, schema) {
	var keys = Object.keys(data);
	var error;
	if (schema.minProperties !== undefined) {
		if (keys.length < schema.minProperties) {
			error = this.createError(ErrorCodes.OBJECT_PROPERTIES_MINIMUM, {propertyCount: keys.length, minimum: schema.minProperties}, '', '/minProperties', null, data, schema);
			if (this.handleError(error)) {
				return error;
			}
		}
	}
	if (schema.maxProperties !== undefined) {
		if (keys.length > schema.maxProperties) {
			error = this.createError(ErrorCodes.OBJECT_PROPERTIES_MAXIMUM, {propertyCount: keys.length, maximum: schema.maxProperties}, '', '/maxProperties', null, data, schema);
			if (this.handleError(error)) {
				return error;
			}
		}
	}
	return null;
};

ValidatorContext.prototype.validateObjectRequiredProperties = function validateObjectRequiredProperties(data, schema) {
	if (schema.required !== undefined) {
		for (var i = 0; i < schema.required.length; i++) {
			var key = schema.required[i];
			if (data[key] === undefined) {
				var error = this.createError(ErrorCodes.OBJECT_REQUIRED, {key: key}, '', '/required/' + i, null, data, schema);
				if (this.handleError(error)) {
					return error;
				}
			}
		}
	}
	return null;
};

ValidatorContext.prototype.validateObjectProperties = function validateObjectProperties(data, schema, dataPointerPath) {
	var error;
	for (var key in data) {
		var keyPointerPath = dataPointerPath + "/" + key.replace(/~/g, '~0').replace(/\//g, '~1');
		var foundMatch = false;
		if (schema.properties !== undefined && schema.properties[key] !== undefined) {
			foundMatch = true;
			if (error = this.validateAll(data[key], schema.properties[key], [key], ["properties", key], keyPointerPath)) {
				return error;
			}
		}
		if (schema.patternProperties !== undefined) {
			for (var patternKey in schema.patternProperties) {
				var regexp = new RegExp(patternKey);
				if (regexp.test(key)) {
					foundMatch = true;
					if (error = this.validateAll(data[key], schema.patternProperties[patternKey], [key], ["patternProperties", patternKey], keyPointerPath)) {
						return error;
					}
				}
			}
		}
		if (!foundMatch) {
			if (schema.additionalProperties !== undefined) {
				if (this.trackUnknownProperties) {
					this.knownPropertyPaths[keyPointerPath] = true;
					delete this.unknownPropertyPaths[keyPointerPath];
				}
				if (typeof schema.additionalProperties === "boolean") {
					if (!schema.additionalProperties) {
						error = this.createError(ErrorCodes.OBJECT_ADDITIONAL_PROPERTIES, {key: key}, '', '/additionalProperties', null, data, schema).prefixWith(key, null);
						if (this.handleError(error)) {
							return error;
						}
					}
				} else {
					if (error = this.validateAll(data[key], schema.additionalProperties, [key], ["additionalProperties"], keyPointerPath)) {
						return error;
					}
				}
			} else if (this.trackUnknownProperties && !this.knownPropertyPaths[keyPointerPath]) {
				this.unknownPropertyPaths[keyPointerPath] = true;
			}
		} else if (this.trackUnknownProperties) {
			this.knownPropertyPaths[keyPointerPath] = true;
			delete this.unknownPropertyPaths[keyPointerPath];
		}
	}
	return null;
};

ValidatorContext.prototype.validateObjectDependencies = function validateObjectDependencies(data, schema, dataPointerPath) {
	var error;
	if (schema.dependencies !== undefined) {
		for (var depKey in schema.dependencies) {
			if (data[depKey] !== undefined) {
				var dep = schema.dependencies[depKey];
				if (typeof dep === "string") {
					if (data[dep] === undefined) {
						error = this.createError(ErrorCodes.OBJECT_DEPENDENCY_KEY, {key: depKey, missing: dep}, '', '', null, data, schema).prefixWith(null, depKey).prefixWith(null, "dependencies");
						if (this.handleError(error)) {
							return error;
						}
					}
				} else if (Array.isArray(dep)) {
					for (var i = 0; i < dep.length; i++) {
						var requiredKey = dep[i];
						if (data[requiredKey] === undefined) {
							error = this.createError(ErrorCodes.OBJECT_DEPENDENCY_KEY, {key: depKey, missing: requiredKey}, '', '/' + i, null, data, schema).prefixWith(null, depKey).prefixWith(null, "dependencies");
							if (this.handleError(error)) {
								return error;
							}
						}
					}
				} else {
					if (error = this.validateAll(data, dep, [], ["dependencies", depKey], dataPointerPath)) {
						return error;
					}
				}
			}
		}
	}
	return null;
};

ValidatorContext.prototype.validateCombinations = function validateCombinations(data, schema, dataPointerPath) {
	return this.validateAllOf(data, schema, dataPointerPath)
		|| this.validateAnyOf(data, schema, dataPointerPath)
		|| this.validateOneOf(data, schema, dataPointerPath)
		|| this.validateNot(data, schema, dataPointerPath)
		|| null;
};

ValidatorContext.prototype.validateAllOf = function validateAllOf(data, schema, dataPointerPath) {
	if (schema.allOf === undefined) {
		return null;
	}
	var error;
	for (var i = 0; i < schema.allOf.length; i++) {
		var subSchema = schema.allOf[i];
		if (error = this.validateAll(data, subSchema, [], ["allOf", i], dataPointerPath)) {
			return error;
		}
	}
	return null;
};

ValidatorContext.prototype.validateAnyOf = function validateAnyOf(data, schema, dataPointerPath) {
	if (schema.anyOf === undefined) {
		return null;
	}
	var errors = [];
	var startErrorCount = this.errors.length;
	var oldUnknownPropertyPaths, oldKnownPropertyPaths;
	if (this.trackUnknownProperties) {
		oldUnknownPropertyPaths = this.unknownPropertyPaths;
		oldKnownPropertyPaths = this.knownPropertyPaths;
	}
	var errorAtEnd = true;
	for (var i = 0; i < schema.anyOf.length; i++) {
		if (this.trackUnknownProperties) {
			this.unknownPropertyPaths = {};
			this.knownPropertyPaths = {};
		}
		var subSchema = schema.anyOf[i];

		var errorCount = this.errors.length;
		var error = this.validateAll(data, subSchema, [], ["anyOf", i], dataPointerPath);

		if (error === null && errorCount === this.errors.length) {
			this.errors = this.errors.slice(0, startErrorCount);

			if (this.trackUnknownProperties) {
				for (var knownKey in this.knownPropertyPaths) {
					oldKnownPropertyPaths[knownKey] = true;
					delete oldUnknownPropertyPaths[knownKey];
				}
				for (var unknownKey in this.unknownPropertyPaths) {
					if (!oldKnownPropertyPaths[unknownKey]) {
						oldUnknownPropertyPaths[unknownKey] = true;
					}
				}
				// We need to continue looping so we catch all the property definitions, but we don't want to return an error
				errorAtEnd = false;
				continue;
			}

			return null;
		}
		if (error) {
			errors.push(error.prefixWith(null, "" + i).prefixWith(null, "anyOf"));
		}
	}
	if (this.trackUnknownProperties) {
		this.unknownPropertyPaths = oldUnknownPropertyPaths;
		this.knownPropertyPaths = oldKnownPropertyPaths;
	}
	if (errorAtEnd) {
		errors = errors.concat(this.errors.slice(startErrorCount));
		this.errors = this.errors.slice(0, startErrorCount);
		return this.createError(ErrorCodes.ANY_OF_MISSING, {}, "", "/anyOf", errors, data, schema);
	}
};

ValidatorContext.prototype.validateOneOf = function validateOneOf(data, schema, dataPointerPath) {
	if (schema.oneOf === undefined) {
		return null;
	}
	var validIndex = null;
	var errors = [];
	var startErrorCount = this.errors.length;
	var oldUnknownPropertyPaths, oldKnownPropertyPaths;
	if (this.trackUnknownProperties) {
		oldUnknownPropertyPaths = this.unknownPropertyPaths;
		oldKnownPropertyPaths = this.knownPropertyPaths;
	}
	for (var i = 0; i < schema.oneOf.length; i++) {
		if (this.trackUnknownProperties) {
			this.unknownPropertyPaths = {};
			this.knownPropertyPaths = {};
		}
		var subSchema = schema.oneOf[i];

		var errorCount = this.errors.length;
		var error = this.validateAll(data, subSchema, [], ["oneOf", i], dataPointerPath);

		if (error === null && errorCount === this.errors.length) {
			if (validIndex === null) {
				validIndex = i;
			} else {
				this.errors = this.errors.slice(0, startErrorCount);
				return this.createError(ErrorCodes.ONE_OF_MULTIPLE, {index1: validIndex, index2: i}, "", "/oneOf", null, data, schema);
			}
			if (this.trackUnknownProperties) {
				for (var knownKey in this.knownPropertyPaths) {
					oldKnownPropertyPaths[knownKey] = true;
					delete oldUnknownPropertyPaths[knownKey];
				}
				for (var unknownKey in this.unknownPropertyPaths) {
					if (!oldKnownPropertyPaths[unknownKey]) {
						oldUnknownPropertyPaths[unknownKey] = true;
					}
				}
			}
		} else if (error) {
			errors.push(error);
		}
	}
	if (this.trackUnknownProperties) {
		this.unknownPropertyPaths = oldUnknownPropertyPaths;
		this.knownPropertyPaths = oldKnownPropertyPaths;
	}
	if (validIndex === null) {
		errors = errors.concat(this.errors.slice(startErrorCount));
		this.errors = this.errors.slice(0, startErrorCount);
		return this.createError(ErrorCodes.ONE_OF_MISSING, {}, "", "/oneOf", errors, data, schema);
	} else {
		this.errors = this.errors.slice(0, startErrorCount);
	}
	return null;
};

ValidatorContext.prototype.validateNot = function validateNot(data, schema, dataPointerPath) {
	if (schema.not === undefined) {
		return null;
	}
	var oldErrorCount = this.errors.length;
	var oldUnknownPropertyPaths, oldKnownPropertyPaths;
	if (this.trackUnknownProperties) {
		oldUnknownPropertyPaths = this.unknownPropertyPaths;
		oldKnownPropertyPaths = this.knownPropertyPaths;
		this.unknownPropertyPaths = {};
		this.knownPropertyPaths = {};
	}
	var error = this.validateAll(data, schema.not, null, null, dataPointerPath);
	var notErrors = this.errors.slice(oldErrorCount);
	this.errors = this.errors.slice(0, oldErrorCount);
	if (this.trackUnknownProperties) {
		this.unknownPropertyPaths = oldUnknownPropertyPaths;
		this.knownPropertyPaths = oldKnownPropertyPaths;
	}
	if (error === null && notErrors.length === 0) {
		return this.createError(ErrorCodes.NOT_PASSED, {}, "", "/not", null, data, schema);
	}
	return null;
};

ValidatorContext.prototype.validateHypermedia = function validateCombinations(data, schema, dataPointerPath) {
	if (!schema.links) {
		return null;
	}
	var error;
	for (var i = 0; i < schema.links.length; i++) {
		var ldo = schema.links[i];
		if (ldo.rel === "describedby") {
			var template = new UriTemplate(ldo.href);
			var allPresent = true;
			for (var j = 0; j < template.varNames.length; j++) {
				if (!(template.varNames[j] in data)) {
					allPresent = false;
					break;
				}
			}
			if (allPresent) {
				var schemaUrl = template.fillFromObject(data);
				var subSchema = {"$ref": schemaUrl};
				if (error = this.validateAll(data, subSchema, [], ["links", i], dataPointerPath)) {
					return error;
				}
			}
		}
	}
};

// parseURI() and resolveUrl() are from https://gist.github.com/1088850
//   -  released as public domain by author ("Yaffle") - see comments on gist

function parseURI(url) {
	var m = String(url).replace(/^\s+|\s+$/g, '').match(/^([^:\/?#]+:)?(\/\/(?:[^:@]*(?::[^:@]*)?@)?(([^:\/?#]*)(?::(\d*))?))?([^?#]*)(\?[^#]*)?(#[\s\S]*)?/);
	// authority = '//' + user + ':' + pass '@' + hostname + ':' port
	return (m ? {
		href     : m[0] || '',
		protocol : m[1] || '',
		authority: m[2] || '',
		host     : m[3] || '',
		hostname : m[4] || '',
		port     : m[5] || '',
		pathname : m[6] || '',
		search   : m[7] || '',
		hash     : m[8] || ''
	} : null);
}

function resolveUrl(base, href) {// RFC 3986

	function removeDotSegments(input) {
		var output = [];
		input.replace(/^(\.\.?(\/|$))+/, '')
			.replace(/\/(\.(\/|$))+/g, '/')
			.replace(/\/\.\.$/, '/../')
			.replace(/\/?[^\/]*/g, function (p) {
				if (p === '/..') {
					output.pop();
				} else {
					output.push(p);
				}
		});
		return output.join('').replace(/^\//, input.charAt(0) === '/' ? '/' : '');
	}

	href = parseURI(href || '');
	base = parseURI(base || '');

	return !href || !base ? null : (href.protocol || base.protocol) +
		(href.protocol || href.authority ? href.authority : base.authority) +
		removeDotSegments(href.protocol || href.authority || href.pathname.charAt(0) === '/' ? href.pathname : (href.pathname ? ((base.authority && !base.pathname ? '/' : '') + base.pathname.slice(0, base.pathname.lastIndexOf('/') + 1) + href.pathname) : base.pathname)) +
		(href.protocol || href.authority || href.pathname ? href.search : (href.search || base.search)) +
		href.hash;
}

function getDocumentUri(uri) {
	return uri.split('#')[0];
}
function normSchema(schema, baseUri) {
	if (schema && typeof schema === "object") {
		if (baseUri === undefined) {
			baseUri = schema.id;
		} else if (typeof schema.id === "string") {
			baseUri = resolveUrl(baseUri, schema.id);
			schema.id = baseUri;
		}
		if (Array.isArray(schema)) {
			for (var i = 0; i < schema.length; i++) {
				normSchema(schema[i], baseUri);
			}
		} else {
			if (typeof schema['$ref'] === "string") {
				schema['$ref'] = resolveUrl(baseUri, schema['$ref']);
			}
			for (var key in schema) {
				if (key !== "enum") {
					normSchema(schema[key], baseUri);
				}
			}
		}
	}
}

function defaultErrorReporter(language) {
	language = language || 'en';

	var errorMessages = languages[language];

	return function (error) {
		var messageTemplate = errorMessages[error.code] || ErrorMessagesDefault[error.code];
		if (typeof messageTemplate !== 'string') {
			return "Unknown error code " + error.code + ": " + JSON.stringify(error.messageParams);
		}
		var messageParams = error.params;
		// Adapted from Crockford's supplant()
		return messageTemplate.replace(/\{([^{}]*)\}/g, function (whole, varName) {
			var subValue = messageParams[varName];
			return typeof subValue === 'string' || typeof subValue === 'number' ? subValue : whole;
		});
	};
}

var ErrorCodes = {
	INVALID_TYPE: 0,
	ENUM_MISMATCH: 1,
	ANY_OF_MISSING: 10,
	ONE_OF_MISSING: 11,
	ONE_OF_MULTIPLE: 12,
	NOT_PASSED: 13,
	// Numeric errors
	NUMBER_MULTIPLE_OF: 100,
	NUMBER_MINIMUM: 101,
	NUMBER_MINIMUM_EXCLUSIVE: 102,
	NUMBER_MAXIMUM: 103,
	NUMBER_MAXIMUM_EXCLUSIVE: 104,
	NUMBER_NOT_A_NUMBER: 105,
	// String errors
	STRING_LENGTH_SHORT: 200,
	STRING_LENGTH_LONG: 201,
	STRING_PATTERN: 202,
	// Object errors
	OBJECT_PROPERTIES_MINIMUM: 300,
	OBJECT_PROPERTIES_MAXIMUM: 301,
	OBJECT_REQUIRED: 302,
	OBJECT_ADDITIONAL_PROPERTIES: 303,
	OBJECT_DEPENDENCY_KEY: 304,
	// Array errors
	ARRAY_LENGTH_SHORT: 400,
	ARRAY_LENGTH_LONG: 401,
	ARRAY_UNIQUE: 402,
	ARRAY_ADDITIONAL_ITEMS: 403,
	// Custom/user-defined errors
	FORMAT_CUSTOM: 500,
	KEYWORD_CUSTOM: 501,
	// Schema structure
	CIRCULAR_REFERENCE: 600,
	// Non-standard validation options
	UNKNOWN_PROPERTY: 1000
};
var ErrorCodeLookup = {};
for (var key in ErrorCodes) {
	ErrorCodeLookup[ErrorCodes[key]] = key;
}
var ErrorMessagesDefault = {
	INVALID_TYPE: "Invalid type: {type} (expected {expected})",
	ENUM_MISMATCH: "No enum match for: {value}",
	ANY_OF_MISSING: "Data does not match any schemas from \"anyOf\"",
	ONE_OF_MISSING: "Data does not match any schemas from \"oneOf\"",
	ONE_OF_MULTIPLE: "Data is valid against more than one schema from \"oneOf\": indices {index1} and {index2}",
	NOT_PASSED: "Data matches schema from \"not\"",
	// Numeric errors
	NUMBER_MULTIPLE_OF: "Value {value} is not a multiple of {multipleOf}",
	NUMBER_MINIMUM: "Value {value} is less than minimum {minimum}",
	NUMBER_MINIMUM_EXCLUSIVE: "Value {value} is equal to exclusive minimum {minimum}",
	NUMBER_MAXIMUM: "Value {value} is greater than maximum {maximum}",
	NUMBER_MAXIMUM_EXCLUSIVE: "Value {value} is equal to exclusive maximum {maximum}",
	NUMBER_NOT_A_NUMBER: "Value {value} is not a valid number",
	// String errors
	STRING_LENGTH_SHORT: "String is too short ({length} chars), minimum {minimum}",
	STRING_LENGTH_LONG: "String is too long ({length} chars), maximum {maximum}",
	STRING_PATTERN: "String does not match pattern: {pattern}",
	// Object errors
	OBJECT_PROPERTIES_MINIMUM: "Too few properties defined ({propertyCount}), minimum {minimum}",
	OBJECT_PROPERTIES_MAXIMUM: "Too many properties defined ({propertyCount}), maximum {maximum}",
	OBJECT_REQUIRED: "Missing required property: {key}",
	OBJECT_ADDITIONAL_PROPERTIES: "Additional properties not allowed",
	OBJECT_DEPENDENCY_KEY: "Dependency failed - key must exist: {missing} (due to key: {key})",
	// Array errors
	ARRAY_LENGTH_SHORT: "Array is too short ({length}), minimum {minimum}",
	ARRAY_LENGTH_LONG: "Array is too long ({length}), maximum {maximum}",
	ARRAY_UNIQUE: "Array items are not unique (indices {match1} and {match2})",
	ARRAY_ADDITIONAL_ITEMS: "Additional items not allowed",
	// Format errors
	FORMAT_CUSTOM: "Format validation failed ({message})",
	KEYWORD_CUSTOM: "Keyword failed: {key} ({message})",
	// Schema structure
	CIRCULAR_REFERENCE: "Circular $refs: {urls}",
	// Non-standard validation options
	UNKNOWN_PROPERTY: "Unknown property (not in schema)"
};

function ValidationError(code, params, dataPath, schemaPath, subErrors) {
	Error.call(this);
	if (code === undefined) {
		throw new Error ("No error code supplied: " + schemaPath);
	}
	this.message = '';
	this.params = params;
	this.code = code;
	this.dataPath = dataPath || "";
	this.schemaPath = schemaPath || "";
	this.subErrors = subErrors || null;

	var err = new Error(this.message);
	this.stack = err.stack || err.stacktrace;
	if (!this.stack) {
		try {
			throw err;
		}
		catch(err) {
			this.stack = err.stack || err.stacktrace;
		}
	}
}
ValidationError.prototype = Object.create(Error.prototype);
ValidationError.prototype.constructor = ValidationError;
ValidationError.prototype.name = 'ValidationError';

ValidationError.prototype.prefixWith = function (dataPrefix, schemaPrefix) {
	if (dataPrefix !== null) {
		dataPrefix = dataPrefix.replace(/~/g, "~0").replace(/\//g, "~1");
		this.dataPath = "/" + dataPrefix + this.dataPath;
	}
	if (schemaPrefix !== null) {
		schemaPrefix = schemaPrefix.replace(/~/g, "~0").replace(/\//g, "~1");
		this.schemaPath = "/" + schemaPrefix + this.schemaPath;
	}
	if (this.subErrors !== null) {
		for (var i = 0; i < this.subErrors.length; i++) {
			this.subErrors[i].prefixWith(dataPrefix, schemaPrefix);
		}
	}
	return this;
};

function isTrustedUrl(baseUrl, testUrl) {
	if(testUrl.substring(0, baseUrl.length) === baseUrl){
		var remainder = testUrl.substring(baseUrl.length);
		if ((testUrl.length > 0 && testUrl.charAt(baseUrl.length - 1) === "/")
			|| remainder.charAt(0) === "#"
			|| remainder.charAt(0) === "?") {
			return true;
		}
	}
	return false;
}

var languages = {};
function createApi(language) {
	var globalContext = new ValidatorContext();
	var currentLanguage;
	var customErrorReporter;
	var api = {
		setErrorReporter: function (reporter) {
			if (typeof reporter === 'string') {
				return this.language(reporter);
			}
			customErrorReporter = reporter;
			return true;
		},
		addFormat: function () {
			globalContext.addFormat.apply(globalContext, arguments);
		},
		language: function (code) {
			if (!code) {
				return currentLanguage;
			}
			if (!languages[code]) {
				code = code.split('-')[0]; // fall back to base language
			}
			if (languages[code]) {
				currentLanguage = code;
				return code; // so you can tell if fall-back has happened
			}
			return false;
		},
		addLanguage: function (code, messageMap) {
			var key;
			for (key in ErrorCodes) {
				if (messageMap[key] && !messageMap[ErrorCodes[key]]) {
					messageMap[ErrorCodes[key]] = messageMap[key];
				}
			}
			var rootCode = code.split('-')[0];
			if (!languages[rootCode]) { // use for base language if not yet defined
				languages[code] = messageMap;
				languages[rootCode] = messageMap;
			} else {
				languages[code] = Object.create(languages[rootCode]);
				for (key in messageMap) {
					if (typeof languages[rootCode][key] === 'undefined') {
						languages[rootCode][key] = messageMap[key];
					}
					languages[code][key] = messageMap[key];
				}
			}
			return this;
		},
		freshApi: function (language) {
			var result = createApi();
			if (language) {
				result.language(language);
			}
			return result;
		},
		validate: function (data, schema, checkRecursive, banUnknownProperties) {
			var def = defaultErrorReporter(currentLanguage);
			var errorReporter = customErrorReporter ? function (error, data, schema) {
				return customErrorReporter(error, data, schema) || def(error, data, schema);
			} : def;
			var context = new ValidatorContext(globalContext, false, errorReporter, checkRecursive, banUnknownProperties);
			if (typeof schema === "string") {
				schema = {"$ref": schema};
			}
			context.addSchema("", schema);
			var error = context.validateAll(data, schema, null, null, "");
			if (!error && banUnknownProperties) {
				error = context.banUnknownProperties(data, schema);
			}
			this.error = error;
			this.missing = context.missing;
			this.valid = (error === null);
			return this.valid;
		},
		validateResult: function () {
			var result = {};
			this.validate.apply(result, arguments);
			return result;
		},
		validateMultiple: function (data, schema, checkRecursive, banUnknownProperties) {
			var def = defaultErrorReporter(currentLanguage);
			var errorReporter = customErrorReporter ? function (error, data, schema) {
				return customErrorReporter(error, data, schema) || def(error, data, schema);
			} : def;
			var context = new ValidatorContext(globalContext, true, errorReporter, checkRecursive, banUnknownProperties);
			if (typeof schema === "string") {
				schema = {"$ref": schema};
			}
			context.addSchema("", schema);
			context.validateAll(data, schema, null, null, "");
			if (banUnknownProperties) {
				context.banUnknownProperties(data, schema);
			}
			var result = {};
			result.errors = context.errors;
			result.missing = context.missing;
			result.valid = (result.errors.length === 0);
			return result;
		},
		addSchema: function () {
			return globalContext.addSchema.apply(globalContext, arguments);
		},
		getSchema: function () {
			return globalContext.getSchema.apply(globalContext, arguments);
		},
		getSchemaMap: function () {
			return globalContext.getSchemaMap.apply(globalContext, arguments);
		},
		getSchemaUris: function () {
			return globalContext.getSchemaUris.apply(globalContext, arguments);
		},
		getMissingUris: function () {
			return globalContext.getMissingUris.apply(globalContext, arguments);
		},
		dropSchemas: function () {
			globalContext.dropSchemas.apply(globalContext, arguments);
		},
		defineKeyword: function () {
			globalContext.defineKeyword.apply(globalContext, arguments);
		},
		defineError: function (codeName, codeNumber, defaultMessage) {
			if (typeof codeName !== 'string' || !/^[A-Z]+(_[A-Z]+)*$/.test(codeName)) {
				throw new Error('Code name must be a string in UPPER_CASE_WITH_UNDERSCORES');
			}
			if (typeof codeNumber !== 'number' || codeNumber%1 !== 0 || codeNumber < 10000) {
				throw new Error('Code number must be an integer > 10000');
			}
			if (typeof ErrorCodes[codeName] !== 'undefined') {
				throw new Error('Error already defined: ' + codeName + ' as ' + ErrorCodes[codeName]);
			}
			if (typeof ErrorCodeLookup[codeNumber] !== 'undefined') {
				throw new Error('Error code already used: ' + ErrorCodeLookup[codeNumber] + ' as ' + codeNumber);
			}
			ErrorCodes[codeName] = codeNumber;
			ErrorCodeLookup[codeNumber] = codeName;
			ErrorMessagesDefault[codeName] = ErrorMessagesDefault[codeNumber] = defaultMessage;
			for (var langCode in languages) {
				var language = languages[langCode];
				if (language[codeName]) {
					language[codeNumber] = language[codeNumber] || language[codeName];
				}
			}
		},
		reset: function () {
			globalContext.reset();
			this.error = null;
			this.missing = [];
			this.valid = true;
		},
		missing: [],
		error: null,
		valid: true,
		normSchema: normSchema,
		resolveUrl: resolveUrl,
		getDocumentUri: getDocumentUri,
		errorCodes: ErrorCodes
	};
	api.language(language || 'en');
	return api;
}

var tv4 = createApi();
tv4.addLanguage('en-gb', ErrorMessagesDefault);

//legacy property
tv4.tv4 = tv4;

return tv4; // used by _header.js to globalise.

}));
/* Tracker SDK 6.1.0 */
 (function() {
/**
 * @module PETracker/app/params
 * @name AppParams
 * @description It have the list of parameters which are used for Initialization
 */
/**
 * AppParams
 * @class PetAppParams
 * @constucts {Object} parameters
 * @description Tracker Initialization parameters
 */

function PetAppParams() {
    /**
     * @member {object}
     */
    this.params = {
        //schemaValidation
        schemaValidation: false,

        //autofill
        autofill: false,

        //debugMode
        debugMode: false,

        originatingSystemCode: 'AutobahnTrackerSDK',

        //cookie rotatory time
        cookieRotatoryTime: '180',

        //cookie expiry time
        cookieExpiryTime: '165',

        // Tracking SDK Version
        sdkVersion: '6.1.0',

        // Current Tracker JS Version
        jsVersion: '6.1.0',

        // Application Platform
        appPlatform: 'web',

        // Application URL
        url: null,

        // Application Environment
        environment: 'production',

        // offline Support
        offlineSupport: false,

        // Cookie Domain Name
        cookieDomainName: 'autobahn',

        // Cookie Prefix
        cookiePrefix: 'gse',

        // Interaction Type | Tracking Event Type
        interactionType: null,

        // synchMode
        synchMode: false,

        //telemetry refresh time
        telemetryHoldtime: 30,

        //telemetry hold size
        telemetryHoldSize: 0.25
    };
}

/**
 * @module PETracker/app/params/general
 * @name GeneralParams
 * @description It have the list of parameters which are used for getting client's contextual information
 */
/**
 * GeneralParams
 * @class PetGeneralParams
 * @constucts {Object} parameters
 * @description Client's contextual parameters
 */
function PetGeneralParams() {
    // custom modules
    var paramHelper = new PetParamsHelper();

    /**
     * @member {object}
     */
    this.params = {

        // User Agent
        useragent: navigator.userAgent,

        // Browser Language
        browserLanguage: window.navigator.userLanguage || window.navigator.language,

        // Dynamic parameters (This will be computed when the request is send)
        // Current Timestamp
        timestamp: null,
    };
}

/**
 * @module PETracker/app/schema
 * @name AppSchema
 * @description It have the JSON schema for validating the App parameters
 */
/**
 * AppSchema
 * @class PetAppSchema
 * @constucts {Object} schema
 * @description JSON Schema for validating the PETracker.init arguments and it's types
 */

function PetAppSchema() {
    /**
     * @member {object}
     */
    this.schema = {
        title: 'App Parameter Schema',
        id: '/app',
        type: 'object',
        properties: {
            originatingSystemCode: {
                type: 'string'
            },
            namespace: {
                type: 'string'
            },
            messageVersion: {
                type: 'string'
            },
            trackingID: {
                type: 'string'
            },
            app: {
                type: 'string'
            },
            sdkVersion: {
                type: 'string'
            },
            appPlatform: {
                type: 'string',
                enum: ['web', 'mobile']
            },
            url: {
                type: 'string',
                format: 'url'
            },
            cookieDomainName: {
                type: 'string'
            },
            cookiePrefix: {
                type: 'string'
            },
            environment: {
                type: 'string'
            },
            autotracking: {
                type: 'array'
            },
            appName: {
                type: 'string'
            },
            appID: {
                type: ['string', 'number']
            },
            appVersion: {
                type: ['string', 'number']
            },
            appInstallerID: {
                type: 'string'
            }
        },
        required: ['trackingID'],
        additionalProperties: true
    };
}

/**
 * @module PETracker/helpers/cookie
 * @name cookie
 * @description It is used to handle Tracking Cookie functionalities
 */
/**
 * PetCookie
 * @class PetCookie
 */
function PetCookie() {
    // constructor code here
}

/** @function
 * @lends PetCookie.prototype
 * @name create
 * @description It is used to create a tracking cookie
 * @param {String} cookieName Cookie's Name
 * @param {String} cookiePrefix Cookie's Prefix
 * @returns {Void} Null
 */
PetCookie.prototype.create = function () {
    var cookieName,
        cookiePrefix,
        cookieValue = JSON.stringify(arguments[3] || {}),
        currentDate = new Date(),
        expires;

    if (cookieValue.length < 4000) {
        cookieName = arguments[0];
        cookiePrefix = arguments[1];
        currentDate.setTime(currentDate.getTime() + arguments[2]);
        expires = 'expires=' + currentDate.toUTCString();

        // cookie creation
        document.cookie = cookiePrefix + cookieName + '=' + encodeURI(cookieValue) + ';path=/';
    }
};

/** @function
 * @lends PetUtils.prototype
 * @name get
 * @description It is used to get the value from cookie
 * @param {String} cookieName Cookie's Name
 * @returns {String} Cookie's Value / Null
 */
PetCookie.prototype.get = function () {
    var cookieName = arguments[0] + '=',
        cookies = document.cookie.split(';'),
        cookie,
        i;

    for (i = 0; i < cookies.length; i++) {
        cookie = cookies[i];
        while (cookie.charAt(0) === ' ') {
            cookie = cookie.substring(1);
        }

        if (cookie.indexOf(cookieName) === 0) {
            return cookie.substring(cookieName.length, cookie.length);
        }
    }

    return '';
};

/**
 * @module PETracker/helpers/datasize
 * @name PetGetDataSize
 * @description It handles offline data size
 */
/**
 * Sdk
 * @class PetGetDataSize
 */
function PetGetDataSize() {
    //constructor
}

/** @function
 * @lends PetGetDataSize.prototype
 * @name roughSizeOfObject
 * @description Calculate the size of the data object
 * @param {Object} object Input data
 * @returns {Number} Value
 */
PetGetDataSize.prototype.roughSizeOfObject = function (object) {
    var objectList = [],
        stack = [object],
        bytes = 0,
        value,
        i;

    while (stack.length) {
        value = stack.pop();

        if (typeof value === 'boolean') {
            bytes += 4;
        } else if (typeof value === 'string') {
            bytes += value.length * 2;
        } else if (typeof value === 'number') {
            bytes += 8;
        } else if (typeof value === 'object' && objectList.indexOf(value) === -1) {
            objectList.push(value);
            for (i in value) {
                stack.push(value[i]);
            }
        }
    }

    return bytes;
};

/** @function
 * @lends PetGetDataSize.prototype
 * @name bytesToSize
 * @description converts bytes to data size in appropriate bytes(KB|MB|GB|TB)
 * @param {Number} bytes Input
 * @returns {Integer} Value
 */
PetGetDataSize.prototype.bytesToSize = function (bytes) {
    var sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'],
        i;
    if (bytes === 0) {
        return 'n/a';
    }

    i = parseInt(Math.floor(Math.log(bytes) / Math.log(1024)));
    return Math.round(bytes / Math.pow(1024, i), 2) + ' ' + sizes[i];
};

/** @function
 * @lends PetGetDataSize.prototype
 * @name convertBytesToMB
 * @description converts bytes to MB
 * @param {Number} num Input
 * @returns {Integer} Value
 */
PetGetDataSize.prototype.convertBytesToMB = function (num) {
    var result = num / 1048576 * 100000;
    return result / 100000;
};
/**
 * @module PETracker/helpers/offline
 * @name PetOffline
 * @description It handles offline data processing
 */
/**
 * Sdk
 * @class PetOffline
 * @constructs offline configurations
 * @param {Object} sdkParams SDK Parameters
 */
function PetOffline(sdkParams) {
    this.eventStorageName = 'events';
    this.activitiesStorageName = 'activities';
    this.telemetryStorageName = 'telemetry';
    this.peEventsData = true;
    this.store = new PetStorage();
    this.ajax = new PetRequest();
    this.getSize = new PetGetDataSize();
    this.receiver = {
        development: '//devapi.english.com/autobahn',
        dev: '//devapi.english.com/autobahn',
        test: '//testapi.english.com/autobahn',
        int: '//testapi.english.com/autobahn',
        stage: '//stageapi.english.com/autobahn',
        stg: '//stageapi.english.com/autobahn',
        prf: '//prfapi.english.com/autobahn',
        production: '//api.english.com/autobahn',
        prd: '//api.english.com/autobahn',
        defaultUrl: '//api.english.com/autobahn'
    };
    this.sdkParams = sdkParams;
    this.peEventData = null;
}

/** @function
 * @lends PetOffline.prototype
 * @name save
 * @description it stores the data into local storage
 * @param {Object} data Input
 * @param {String} type Input
 * @returns {Void} Null
 */
PetOffline.prototype.save = function (data, type) {
    if (data) {
        if(type === 'events'){
            if (data.data.events[0].payload.messageTransferType){
                data.data.events[0].payload.messageTransferType = "OfflineCacheUpload";
            } 
        } else {
            if (data.data.activities[0].payload.messageTransferType){
                data.data.activities[0].payload.messageTransferType = "OfflineCacheUpload";
            } 
        }            
        var storageName = type === 'events' ? this.eventStorageName : this.activitiesStorageName;
        this.peEventData = this.store.get(storageName);
        if (!this.peEventData) {
            this.peEventData = [data];
        } else {
            this.peEventData.push(data);
        }

        this.store.set(storageName, this.peEventData);
    }
};

/** @function
 * @lends PetOffline.prototype
 * @name checkData
 * @description Check the data in local storage
 * @returns {Void} Null
 */
PetOffline.prototype.checkData = function () {
    // local variables
    var recordsChunkLimit,
        i,
        indexStart,
        indexEnd,
        dataArr,
        j,
        sdkData;

    this.peEventData = this.store.get(this.eventStorageName);
    this.peActivityData = this.store.get(this.activitiesStorageName);

    if (this.peEventData) {
        dataArr = [];
        if (this.peEventData.length > 20) {
            dataArr = this.peEventData.slice(0, 20);
        } else {
            dataArr = this.peEventData;
        }

        this.send(dataArr, 'events', dataArr.length);
    }

    if (this.peActivityData) {
        dataArr = [];
        if (this.peActivityData.length > 20) {
            dataArr = this.peActivityData.slice(0, 20);
        } else {
            dataArr = this.peActivityData;
        }

        this.send(dataArr, 'activities', dataArr.length);
    }
};

/** @function
 * @lends PetOffline.prototype
 * @name checkData
 * @description Check the data in local storage
 * @returns {Void} void
 */
PetOffline.prototype.checkTelemetrydata = function () {
    var self = this,
        keys,
        data_list;
    this.telemetryData = this.store.get(this.telemetryStorageName);
    if (this.telemetryData) {
        keys = Object.keys(this.telemetryData);
        keys.forEach(function (key) {
            var data = self.telemetryData[key].telemetryData, createdTime = new Date(self.telemetryData[key].timeStamp),
                isSizexceeded = self.getAllowedDataChunk(data, self.sdkParams.telemetryHoldSize);
            if (isSizexceeded || (((new Date().getTime() - createdTime.getTime()) / 1000) > (self.sdkParams.telemetryHoldtime))) {
                data_list = data.data || {};
                if (data_list.activities || data_list.events) {
                    if (data_list.activities) {
                        data_list.activities = data_list.activities.filter(function (x) {
                            return x.payload && (x.payload.userTelemetryPageActions.length > 0 || x.payload.userTelemetryPageErrors.length > 0)
                        });
                        if (data_list.activities.length > 0) {
                            self.send(data, 'telemetry', key);
                        } else {
                            delete self.telemetryData[key];
                            self.store.set(self.telemetryStorageName, self.telemetryData);
                        }
                    } else if (data_list.events) {
                        if (data_list.events) {
                            data_list.events = data_list.events.filter(function (x) {
                                return x.payload && (x.payload.userTelemetryPageActions.length > 0 || x.payload.userTelemetryPageErrors.length > 0)
                            });
                            if (data_list.events.length > 0) {
                                self.send(data, 'telemetry', key);
                            } else {
                                delete self.telemetryData[key];
                                self.store.set(self.telemetryStorageName, self.telemetryData);
                            }
                        }
                    }
                }
            }
        });
    }
};

/** @function
 * @lends PetOffline.prototype
 * @name getAllowedDataChunk
 * @description It sends the data from local storage to tracking system
 * @param {Object} peEventData Input Object
 * @param {Number} size Input Size
 * @return {Number} Size of Data
 */
PetOffline.prototype.getAllowedDataChunk = function (peEventData, size) {
    return this.getSize.convertBytesToMB(this.getSize.roughSizeOfObject(peEventData)) > (size || 0.20);

};

/** @function
 * @lends PetOffline.prototype
 * @name send
 * @description It sends the data from local storage to tracking system
 * @param {Object} sdkData Input Data
 * @param {Number} type Event Type
 * @param {Number} sentCount Records count
 * @returns {Void} void
 */
PetOffline.prototype.send = function (sdkData, type, sentCount) {
    // local variables
    var receiverUrl,
        self = this,
        data,
        xmlhttp;
    if (this.sdkParams.apiEndpoint) {
        receiverUrl = this.sdkParams.apiEndpoint + '/autobahn';
    } else if (typeof this.receiver[this.sdkParams.environment] !== 'undefined') {
        receiverUrl = this.receiver[this.sdkParams.environment];
    } else {
        receiverUrl = this.receiver.defaultUrl;
    }

    if (type === 'telemetry') {
        receiverUrl += '/collect/events';
    } else {
        receiverUrl += '/collect/' + type;
    }

    data = {
        trackingID: self.sdkParams.trackingID,
        sdkVersion: self.sdkParams.sdkVersion,
        synchMode: self.sdkParams.synchMode
    };
    xmlhttp = this.ajax.sendXMLHTTP(receiverUrl, sdkData, data);
    // Handling response from Receiver
    xmlhttp.onreadystatechange = function () {
        var localStorageName = type === 'events' ? self.eventStorageName : (type === 'activities' ? self.activitiesStorageName : self.telemetryStorageName),
            peEventsData,
            telemteryStoragedata;
        if (xmlhttp.readyState === 4) {
            peEventsData = self.store.get(localStorageName);
            if (type === 'telemetry') {
                if(xmlhttp.status == 0  || xmlhttp.status > 500){
                    telemteryStoragedata = self.store.get(localStorageName);
                    for (x in telemteryStoragedata){
                        telemteryStoragedata[x]['telemetryData']['data']['events'][0].payload.messageTransferType = "OfflineCacheUpload";
                        self.store.set(localStorageName, telemteryStoragedata);
                    }
                } else {
                    telemteryStoragedata = self.store.get(localStorageName);
                    delete telemteryStoragedata[sentCount];
                    self.store.set(localStorageName, telemteryStoragedata);                   
                }
            } else {
                if (peEventsData) {
                    if (peEventsData.length === sentCount) {
                        self.store.delete(localStorageName);
                    } else {
                        peEventsData.splice(0, sentCount);
                        self.store.set(localStorageName, peEventsData);
                    }
                }
            }
        }
    };
};


/** @function
 * @lends PetOffline.prototype
 * @name isNetworkAvailable
 * @description It checks if active network connection is available, invokes checking local storage if connection is active
 * @param {Boolean} isTelemetry Telemetry Flag
 * @returns {Void} void
 */
PetOffline.prototype.isNetworkAvailable = function (isTelemetry) { 
    // local variables

    var self = this;
    if (isTelemetry) {    
        self.checkTelemetrydata(); 
    } else {
        self.checkData();
    }
};



/**
 * @module PETracker/helpers/params
 * @name params
 * @description It is used to detect the default values and client's contextual information
 */
/**
 * PetParamsHelper
 * @class PetParamsHelper
 */
function PetParamsHelper() {
    // constructor code here
}

/** @function
 * @lends PetParamsHelper.prototype
 * @name getUserAgent
 * @description It is used to detect the user agent of client application
 * @return {String} userAgent
 */
PetParamsHelper.prototype.getUserAgent = function () {
    return encodeURIComponent(navigator.userAgent);
};

/** @function
 * @lends PetParamsHelper.prototype
 * @name getTimestamp
 * @description Returns current timestamp of client side app
 * @return {String} timestamp
 */
PetParamsHelper.prototype.getTimestamp = function () {
    return (new Date()).toISOString();
};

/** @function
 * @lends PetParamsHelper.prototype
 * @name getParameterByName
 * @description Returns current value by parameter name
 * @param {String} name Input Parameter
 * @return {String} Parameter
 */
PetParamsHelper.prototype.getParameterByName = function (name) {
    var regex, results;
    name = name.replace(/[\[]/, '\\[').replace(/[\]]/, '\\]');
    regex = new RegExp('[\\?&]' + name + '=([^&#]*)');
    results = regex.exec(location.search);
    return results === null ? '' : decodeURIComponent(results[1].replace(/\+/g, ' '));
};

/** @function
 * @lends PetParamsHelper.prototype
 * @name getUtmParam
 * @description It returns the UTM parameters
 * @param {String} paramName Input Parameter
 * @return {String} Value
 */
PetParamsHelper.prototype.getUtmParam = function (paramName) {
    return this.getParameterByName(paramName);
};

/** @function
 * @lends PetParamsHelper.prototype
 * @name getBrowserLanguage
 * @description It returns the Browser Language
 * @param {String} paramName Input Parameter
 * @return {String} Value
 */
PetParamsHelper.prototype.getBrowserLanguage = function (paramName) {
    return window.navigator.userLanguage || window.navigator.language;
};

/**
 * @module PETracker/helpers/request
 * @name request
 * @description It is used to send the data to Tracking System
 * @description Prerequsites: Offline-tracking/interval-based processing.
 * @description if user manually sets time interval to process data, it should be greater than or equal to 15 seconds (15000 in ms) else default value will take precedence (60000 in ms)
 */
/**
 * @member {String/Number} time-based/offline tracking.
 */
var petIntervalId = null;

/**
 * PetCookie
 * @class PetRequest
 * @param {Object} sdkParams Input Object
 */
function PetRequest(sdkParams) {
    /**
     * @member {Object} tracking system receiver api URLs
     */
    this.receiver = {
        development: '//devapi.english.com/autobahn',
        dev: '//devapi.english.com/autobahn',
        test: '//testapi.english.com/autobahn',
        int: '//testapi.english.com/autobahn',
        stage: '//stageapi.english.com/autobahn',
        stg: '//stageapi.english.com/autobahn',
        prf: '//prfapi.english.com/autobahn',
        production: '//api.english.com/autobahn',
        prd: '//api.english.com/autobahn',
        defaultUrl: '//api.english.com/autobahn'
    };

    this.sdkParams = sdkParams;
}

/** @function
 * @lends PetRequest.prototype
 * @name send
 * @description It is used to create a tracking cookie
 * @param {Object} sdkParams Input Params
 * @param {Object} sdkErrors Schema Errors
 * @param {Function} callback Callback Function
 * @returns {void} Void
 */
PetRequest.prototype.send = function () {
    // custom modules
    var cookieHelper = new PetCookie(),
        utilsHelper = new PetUtilsHelper(),
        
        // arguments
        data = utilsHelper.clone(arguments[1]), // Getting parameter list
        callback = arguments[3], // Getting user's callback
        method = arguments[4], // Getting method for the Request
        options = arguments[2],

        // local variables
        result,
        xmlhttp,
        receiverUrl,
        cookieName = '__PET',
        cookieValue = cookieHelper.get(cookieName),
        offineEnabled = options && options.offlineEnabled,
        localStorageAvailable = false,
        offline,
        intervalToProcess;

    if (this.sdkParams.apiEndpoint) {
        receiverUrl = this.sdkParams.apiEndpoint + '/autobahn';
    } else if (typeof this.receiver[options.environment] !== 'undefined') {
        receiverUrl = this.receiver[options.environment];
    } else {
        receiverUrl = this.receiver.defaultUrl;
    }

    if (typeof (Storage) === 'undefined') {
        // console.error('PETracker: no local storage found.');
    } else {
        localStorageAvailable = true;
        if (offineEnabled) {
            offline = new PetOffline(this.sdkParams);
        }
    }

    // Tracking Data formation
    result = {
        data: utilsHelper.removeNullParameters(utilsHelper.getDefaultValues(data))
    };

    if (offineEnabled && localStorageAvailable) {
        if(options.onlineEnabled){
            xmlhttp = this.sendXMLHTTP(receiverUrl + arguments[0], result, options, method);
            // Handling response from Receiver
            xmlhttp.onreadystatechange = function () {
                if (xmlhttp.readyState === 4 && xmlhttp.status === 200) {
                    if (typeof callback === 'function') {
                        callback(null, JSON.parse(xmlhttp.responseText));
                    }
                } else if (xmlhttp.readyState === 4) {
                    if (typeof callback === 'function') {
                        callback({
                            error: xmlhttp.status
                        });
                    }
                }
            };
        } else {
            offline.save(result, options.eventType);
            intervalToProcess = 15000;
            if ((typeof data.intervalToProcess !== 'undefined') && (data.intervalToProcess) && (data.intervalToProcess >= 15000)) {
                intervalToProcess = data.intervalToProcess;
            }

            if (!petIntervalId) { // this checking prevents creating multiple interval IDs
                petIntervalId = setInterval(this.checkNetworkAvailable.bind(this), intervalToProcess);
            }

            if (typeof callback === 'function') {
                callback(null, { message: 'Data successfully stored in offline..' });
            }
        }
        
    }

    // LS not available or it means offline won't work even if enabled.
    if (!offineEnabled || !localStorageAvailable) {
        xmlhttp = this.sendXMLHTTP(receiverUrl + arguments[0], result, options, method);

        // Handling response from Receiver
        xmlhttp.onreadystatechange = function () {
            if (xmlhttp.readyState === 4 && xmlhttp.status === 200) {
                if (typeof callback === 'function') {
                    callback(null, JSON.parse(xmlhttp.responseText));
                }
            } else if (xmlhttp.readyState === 4) {
                if (typeof callback === 'function') {
                    callback({
                        error: xmlhttp.status
                    });
                }
            }
        };
    }

};

/** @function
 * @lends PetRequest.prototype
 * @name sendXMLHTTP
 * @description It is used to send data to tracking system
 * @param  {String} url [URL to make XMLHTTPREQUEST call]
 * @param  {Object} eventData [The data to send to external URL]
 * @param  {Object} options [object that contains necessary params (appId, sdkVersion etc.)]
 * @param {String} method Request Method
 * @returns {Object} [returns XMLHTTPREQUEST object]
 */
PetRequest.prototype.sendXMLHTTP = function (url, eventData, options, method) {
    method = method || 'POST';

    //Making HTTP Request to Receiver
    var xmlhttp,
        supportedProtocols = ['https:', 'http:'],
        requestProtocol;

    if (window.XMLHttpRequest) { // code for IE7+, Firefox, Chrome, Opera, Safari
        xmlhttp = new XMLHttpRequest();
    } else { // code for IE6, IE5
        xmlhttp = new ActiveXObject('Microsoft.XMLHTTP');
    }

    requestProtocol = (supportedProtocols.indexOf(window.location.protocol) > -1) ? window.location.protocol : 'https:';
    xmlhttp.open(method, url, true);
    xmlhttp.setRequestHeader('Content-Type', 'application/json');
    xmlhttp.setRequestHeader('Access-Control-Allow-Origin', '*');
    xmlhttp.setRequestHeader('PETRACKER-TRACKING-ID', options.trackingID);
    if (options.synchMode) {
        xmlhttp.setRequestHeader('PETRACKER-SYNCHMODE', options.synchMode);
    }

    xmlhttp.send(JSON.stringify(eventData));
    return xmlhttp;
};

/** @function
 * @lends PetRequest.prototype
 * @name sendXMLHTTP
 * @description It is used to send data to tracking system
 * @returns {void} void
 */
PetRequest.prototype.checkNetworkAvailable = function () {
    var offline = new PetOffline(this.sdkParams);
    offline.isNetworkAvailable();
};

/**
 * @module PETracker/helpers/storage
 * @name PetStorage
 * @description It is the wrapper of Local Storage operations
 */
/**
 * Sdk
 * @class PetStorage
 */
function PetStorage() {
    //constructor
}

/** @function
 * @lends PetStorage.prototype
 * @name set
 * @description It stores the data into local storage
 * @param {String} key Key
 * @param {String} value Value
 * @returns {Void} void
 */
PetStorage.prototype.set = function (key, value) {
    value = JSON.stringify(value);
    localStorage.setItem(key, value);
};

/** @function
 * @lends PetStorage.prototype
 * @name get
 * @description It get the data from local storage
 * @param {String} key Index
 * @returns {Object} data
 */
PetStorage.prototype.get = function (key) {
    var data = localStorage.getItem(key);
    return JSON.parse(data);
};

/** @function
 * @lends PetStorage.prototype
 * @name delete
 * @description It removes the data from local storage
 * @param {String} key Key
 * @returns {Boolean} Removed or not
 */
PetStorage.prototype.delete = function (key) {
    return localStorage.removeItem(key);
};
/**
 * @module PETracker/helpers/utils
 * @name utils
 * @description It have helper functions to manipulate and format the input
 */
/**
 * PetUtils
 * @class PetUtils
 * @requires module:PETracker/helpers/params
 */
function PetUtilsHelper() {
    /**
     * @member ParamsHelper
     */
    this.paramsHelper = new PetParamsHelper();
}

/** @function
 * @lends PetUtils.prototype
 * @name merge
 * @description It is used to merge two objects
 * @param {Object} object1 input
 * @param {Object} object2 input
 * @returns {Object} result
 */
PetUtilsHelper.prototype.merge = function (object1, object2) {
    if (arguments.length === 2 && (typeof object1 === 'object') && (typeof object2 === 'object')) {
        for (var attribute in object2) {
            object1[attribute] = object2[attribute];
        }

        return object1;
    }

    return object1;
};

/** @function
 * @lends PetUtils.prototype
 * @name getUuid
 * @description It is used to generate the UUID for Tracker SDK
 * @returns {String} UUID
 */
PetUtilsHelper.prototype.getUuid = function () {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
        var r = Math.random() * 16 | 0;
        v = c === 'x' ? r : (r & 0x3 | 0x8);
        return v.toString(16);
    });
};

/** @function
 * @lends PetUtils.prototype
 * @name getClientId
 * @description It is used to get the ClientID from GA and Gtag
 * @returns {String} clientId
 */
PetUtilsHelper.prototype.getClientId = function () {
    var clientId = petWindowObj.PETPageID;
    if (typeof ga === 'function') {
        try {
            clientId = ga.getAll()[0].get('clientId');
            return clientId;
        }
        catch (e) {
            return clientId;
        }
    }

    return clientId;
};

/** @function
 * @lends PetUtils.prototype
 * @name getValue
 * @description It is used to detect the value of given parameter
 * @param {String} attribute input
 * @returns {String/NULL} value
 */
PetUtilsHelper.prototype.getValue = function (attribute) {
    // custom modules
    var paramHelper = new PetParamsHelper();

    switch (attribute) {
        case 'documentLocation':
            return encodeURIComponent(window.location.href);
        case 'documentHost':
            return window.location.hostname;
        case 'documentPage':
            return window.location.pathname;
        case 'documentTitle':
            return encodeURIComponent(document.title);
        case 'timestamp':
            return (new Date()).toISOString();
        case 'url':
            return document.location.href;
        case 'useragent':
            return paramHelper.getUserAgent();
        case 'documentReferrer':
            return document.referrer;
        default:
            return '';
    }
};

/** @function
 * @lends PetUtils.prototype
 * @name clone
 * @description Returns the clone to input
 * @param {Object} value input
 * @returns {Object} value
 */
PetUtilsHelper.prototype.clone = function (value) {
    return JSON.parse(JSON.stringify(value));
};

/** @function
 * @lends PetUtils.prototype
 * @name getDefaultValues
 * @description It process the inputs, stores the default value and return the result
 * @param {Object} input input
 * @returns {Object} input
 */
PetUtilsHelper.prototype.getDefaultValues = function (input) {
    for (var attribute in input) {
        if (input[attribute] === null || input[attribute] === '') {
            input[attribute] = this.getValue(attribute);
        }

    }

    return input;
};

/** @function
 * @lends PetUtils.prototype
 * @name removeNullParameters
 * @description This method removes the null values from data and return result
 * @param {Object} data input
 * @returns {Object} data
 */
PetUtilsHelper.prototype.removeNullParameters = function (data) {
    // property to be removed  if it exits in object
    var list = ['autotracking'],
        attribute;

    if (typeof data === 'object') {
        for (attribute in data) {
            try {
                if (data[attribute] === null || data[attribute] === undefined || data[attribute] === '') {
                    delete data[attribute];
                } else if (typeof data[attribute] === 'object' && Object.keys(data[attribute]).length === 0) {
                    delete data[attribute];
                }

                if (list.indexOf(attribute) !== -1) {
                    delete data[attribute];
                }
            }

            catch (e) {
                //console.log(e);
            }
        }

        return data;
    }

    return data;
};

/** @function
 * @lends PetUtils.prototype
 * @name getErrorMessages
 * @description This method process the error messages and return the result
 * @param {Object} data input
 * @returns {Object} data
 */
PetUtilsHelper.prototype.getErrorMessages = function (data) {
    // local variables
    var resultData = [];

    if (data) {
        data.forEach(function (el, i) {
            resultData.push((el.dataPath).substr(1) + ': ' + el.message);
        });
    }

    return resultData;
};

/**
 * @module PETracker/user/params
 * @name UserParams
 * @description It have the user's parameters list
 */
/**
 * PetUserParams
 * @class PetUserParams
 * @constructs User params
 */
function PetUserParams() {
    /**
     * @member {object}
     */
    this.params = {
        // application user id
        userID: 'anonymous',

        // User's session ID
        internalSessionID: '',
    };
}

/**
 * @module PETracker/events/IP
 * @name IP
 * @description It is used to capture IP of Client
 */
/**
 * Sdk
 * @class PetSDKIP
 * @constructs PetSDKIP configurations and eventParameters
 * @param {Object} sdkParams SDK Parameters
 */
function PetSDKIP(sdkParams) {
    this.sdkParams = sdkParams;
}

/** @function
 * @lends PetSDKIP.prototype
 * @name getIP
 * @description Getting IP Address
 * @param {Function} callback Callback Function
 * @returns {Void} void
 */
PetSDKIP.prototype.getIP = function (callback) {
    var ajaxRequest = new PetRequest(this.sdkParams),
        url = '';
    ajaxRequest.send(url, {}, { trackingID: this.sdkParams.trackingID, offlineEnabled: false, environment: this.sdkParams.environment }, function (err, data) {
        if (data && data.ipv4) {
            callback(200, data.ipv4);
        }
        else {
            callback(500, 'Unable to fetch IP');
        }
    }, 'GET');
};

/**
 * @module PETracker/events/sendMessage
 * @name sendEvent
 * @description It is a generic event to send tracking data
 */
var autobahUrls = {
    messaging: '/collect',
    schema: '/schemas',
    collection: '/collection'
};

/**
 * Sdk
 * @class PetMessage
 * @constructs PetMessage configurations and eventParameters
 * @param {Object} sdkParams Input Params
 */
function PetMessage(sdkParams) {

    this.eventParams = {
        isSendMessage: true,
        interactionType: 'event',
        sdkParams: sdkParams
    };
}

function catchSchemaError(data, sdkParams) {
    if (sdkParams.debugMode) {
        console.error('Payload has not been sent due to schema valaidation error.', data.error);
    } else {
        var ajaxRequest = new PetRequest(sdkParams),
            url = autobahUrls.collection + '/' + sdkParams.trackingID;
        ajaxRequest.send(url, data, { trackingID: sdkParams.trackingID, offlineEnabled: false, environment: sdkParams.environment }, false);
    }
}

function autofillParameters(data, schema, sdkParams) {
    if (schema.properties) {
        for (var key in schema.properties) {
            if (sdkParams[key]) {
                data[key] = data[key] || sdkParams[key];
            }
        }

        if (Object.keys(schema.properties).indexOf('messageTypeCode') === -1) {
            delete data.messageTypeCode;
        }
    }

    return data;
}

function autobahnSchemaCookieValidator(event, isSchemaNeeded) {
    var cookieFilter = document.cookie.split(';').filter(function (value) {
        return value.indexOf(event.namespace + '-' + event.messageTypeCode + '-' + ((event.messageVersion) ? event.messageVersion : 'latest')) > -1;
    });

    if (cookieFilter.length > 0) {
        body = JSON.parse(decodeURI(cookieFilter[0].split('=')[1]));
        if (isSchemaNeeded && body.schema) {
            return body;
        } else if (isSchemaNeeded && !body.schema) {
            cookie = new PetCookie();
            cookie.create(event.namespace + '-' + event.messageTypeCode + '-' + ((event.messageVersion) ? event.messageVersion : 'latest'), '', (-60) * 60 * 1000, '');
            return false;
        }

        return body;
    }

    return false;
}

function autobahnValidator(eventParams, event, callback) {
    if (event.namespace && event.messageTypeCode) {
        if (!eventParams.schemaValidation && !eventParams.autofill && event.messageVersion.toLowerCase() !== 'latest') {
            if (typeof callback === 'function') {
                callback(null, event);
                return null;
            }
        }

        var schemaFoundInCookie = autobahnSchemaCookieValidator(event, eventParams.schemaValidation || eventParams.autofill),
            schemaValidationResult,
            urlFormatter,
            ajax,
            messageVersion,
            schema,
            cookie;
        if (schemaFoundInCookie) {
            if (event.messageVersion.toLowerCase() === 'latest') {
                event.messageVersion = schemaFoundInCookie.version;
            }

            if (schemaFoundInCookie.schema && Object.keys(schemaFoundInCookie.schema.properties).indexOf('messageTypeCode') === -1) {
                delete event.payload.messageTypeCode;
            } else if (!schemaFoundInCookie.schema) {
                delete event.payload.messageTypeCode;
            }

            if (eventParams.autofill) {
                event.payload = autofillParameters(event.payload, schemaFoundInCookie.schema, eventParams);
            }

            if (eventParams.schemaValidation) {
                schemaValidationResult = tv4.validateMultiple(event.payload, schemaFoundInCookie.schema, true);
                if (!schemaValidationResult.valid) {
                    event.error = schemaValidationResult;
                    catchSchemaError(event, eventParams);
                    return false;
                }
            }

            if (typeof callback === 'function') {
                callback(null, event);
            }

            return null;
        }

        urlFormatter = autobahUrls.schema + '/';
        urlFormatter += event.namespace + '/' + event.messageTypeCode + '/' + (event.messageVersion ? event.messageVersion : 'latest');
        ajax = new PetRequest(eventParams);
        ajax.send(urlFormatter, {}, { trackingID: eventParams.trackingID, offlineEnabled: false, environment: eventParams.environment }, function (err, data) {
            if (err && err.error !== 200) {
                if (typeof callback === 'function') {
                    callback(err);
                }
            } else if (data && data.code === 200 && data.response) {
                messageVersion = event.messageVersion;
                data = data.response;
                if (messageVersion.toLowerCase() === 'latest') {
                    event.messageVersion = data.version;
                }

                if (eventParams.autofill) {
                    event.payload = autofillParameters(event.payload, data.schemaDefinition, eventParams);
                }

                if (Object.keys(data.schemaDefinition.properties).indexOf('messageTypeCode') === -1) {
                    delete event.payload.messageTypeCode;
                }

                schema = data.schemaDefinition;
                schemaValidationResult = tv4.validateMultiple(event.payload, schema, true);
                cookie = new PetCookie();
                var cookieData = {};
                if (eventParams.schemaValidation || eventParams.autofill) {
                    cookieData = { schema: schema, version: data.version };
                } else {
                    cookieData = { version: data.version };
                }

                if (JSON.stringify(cookieData).length < 4000) {
                    cookie.create(event.namespace + '-' + event.messageTypeCode + '-' + (messageVersion ? messageVersion : 'latest'), '', (eventParams.cookieExpiryTime || 180) * 60 * 1000, cookieData);
                }

                if (!schemaValidationResult.valid && eventParams.schemaValidation) {
                    event.error = schemaValidationResult;
                    catchSchemaError(event, eventParams);
                    return false;
                }

                if (typeof callback === 'function') {
                    callback(null, event);
                }
            }

            return null;
        }, 'GET');
    } else {
        callback({ err: 'Required Parameter missing Namespace or MessageTypeCode missing.' });
    }

    return null;
}

/** @function
 * @lends PetMessage.prototype
 * @name track
 * @description It is a generic method to track all events
 * @param {Array} Input data from app
 * @param {Object} sdkParams SDK Params
 * @param {Object} sdkErrors SDK Errors
 * @returns {Void} Null
 */
PetMessage.prototype.track = function () {
    // Dependencies
    var dataClone = arguments[1],
        eventUrl = arguments[0],
        options = arguments[2],
        userCallback = arguments[3],
        self = this,
        utilHelper = new PetUtilsHelper(),
        formatPayload;

    formatPayload = {
        messageTypeCode: (dataClone && (dataClone.messageTypeCode || dataClone.Message_Type_Code)),
        messageVersion: (options && options.messageVersion) || this.eventParams.sdkParams.messageVersion || 'latest',
        actionType: 'create',
        namespace: (options && options.namespace) || this.eventParams.sdkParams.namespace,
        payload: dataClone || {}
    };
    eventData = {
        originatingSystemCode: (options && options.originatingSystemCode) || this.eventParams.sdkParams.originatingSystemCode
    };
    eventData[eventUrl] = [utilHelper.merge(options || {}, formatPayload)];
    if (!formatPayload.messageTypeCode) {
        console.error('Message Typecode is a required property.');
        return false;
    }

    autobahnValidator(this.eventParams.sdkParams, formatPayload, function (err, validatedData) {
        if (err) {
            console.error(err);
        } else {
            var ajax = new PetRequest(self.eventParams.sdkParams),
                url = autobahUrls.messaging + '/' + eventUrl,
                data = {};

            data[eventUrl] = [utilHelper.merge(options || {}, validatedData)];
            data.originatingSystemCode = (options && options.originatingSystemCode) || self.eventParams.sdkParams.originatingSystemCode;
            ajax.send(url, data, { trackingID: self.eventParams.sdkParams.trackingID, offlineEnabled: self.eventParams.sdkParams.offlineSupport,onlineEnabled: options.online, environment: self.eventParams.sdkParams.environment, eventType: eventUrl, synchMode: self.eventParams.sdkParams.synchMode }, userCallback);
        }
    });

    return null;
};
function PetPageId() {
    this.utilHelper = new PetUtilsHelper;
    //this.passID = new passpageID;
    this.petPageLocation = petWindowObj.location.href;
}

/** @function
 * @lends PetPageId.prototype
 * @name autoPageId
 * @description It is a method to Generate pageID automatically
 * @returns {String} value
 */
PetPageId.prototype.autoPageId = function () {
    var self = this,
        isPageNavigated,
        date = Date.now();
    petWindowObj.PETPageID = this.utilHelper.getUuid() + '-' + date;
    this.petPageLocation = petWindowObj.location.href;

    isPageNavigated = function () {
        var date = Date.now(), currentPage = petWindowObj.location.href;
        if (currentPage !== self.petPageLocation) {
            self.petPageLocation = currentPage;
            petWindowObj.PETPageID = self.utilHelper.getUuid() + '-' + date;
        }
    };
    setInterval(isPageNavigated, 500);
};

/** @function
 * @lends PetPageId.prototype
 * @name get
 * @description It is a method to return pageID
 * @returns {String} value
 */
PetPageId.prototype.get = function () {
    return petWindowObj.PETPageID;
};

/** @function
 * @lends PetPageId.prototype
 * @name autoPageId
 * @description It is a method to Generate pageID and return value
 * @returns {String} value
 */
PetPageId.prototype.generate = function () {
    var date = Date.now();
    petWindowObj.PETPageID = this.utilHelper.getUuid() + '-' + date;
    return this.get();
};
/**
 * @module PETracker/init
 * @name init
 * @description It is used to initialize the Tracker SDK Object in Application
 */
// @member {Object} petWindowObj
var petWindowObj = window;

// Check the PETracker is initialized or not
if (!petWindowObj._petracker) {
    utilHelper = new PetUtilsHelper();
    petPageLocation = petWindowObj.location.href;
    petWindowObj._petracker = 'PETracker';
  	petWindowObj.PETClientID = utilHelper.getClientId();

    // exporting the PETracker Object
    petWindowObj.PETracker = new PetSdk();
}

/**
 * @module PETracker/sdk
 * @name sdk
 * @description It is used to init the Tracker object via PETracker Object
 */
/**
 * Sdk
 * @class PetSdk
 * @constructs PETracker.CONSTANTS
 */
function PetSdk() {
    /**
     * @member {Object} utilHelper
     */
    var utilHelper;

    utilHelper = new PetUtilsHelper();

    // Adding URL Format for Schema Validation
    tv4.addFormat('url', function (data, schema) {
        var regexp = /(ftp|http|https):\/\/(\w+:{0,1}\w*@)?(\S+)(:[0-9]+)?(\/|\/([\w#!:.?+=&%@!\-\/]))?/;
        if (regexp.test(data)) {
            return null;
        }

        return 'Invalid URL Specificied Here.';
    });
}

/** @function
 * @lends petSdk.prototype
 * @name init
 * @description It is used to verify the app credentials and initialize the tracker events
 * @param {String} appID - Tracking Id of the application
 * @param {Object} config - Customized Tracking configurations
 * @returns {Object} trackerObject
 */
PetSdk.prototype.init = function () {
    // helper modules
    var utilHelper = new PetUtilsHelper(),

        // local variables
        appData = {
            trackingID: null
        },
        appSchema = new PetAppSchema().schema,
        appParams = new PetAppParams().params,
        sdkParams = {},
        sdkErrors = {},
        schemaResult = {},
        tracker,
        self = this,
        pageId;

    if (typeof arguments[0] !== 'string') {
        console.error('App Id must be a valid string type..');
        return;
    }

    //validating the apiEndpoint
    regexp = /(ftp|http|https):\/\/(\w+:{0,1}\w*@)?(\S+)(:[0-9]+)?(\/|\/([\w#!:.?+=&%@!\-\/]))?/;
    if (arguments[1]) {
        if (arguments[1].apiEndpoint) {
            apiEndpointLength = arguments[1].apiEndpoint.length;

            if (!regexp.test(arguments[1].apiEndpoint)) {
                console.error('apiEndpoint is not the valid domain');
                return;
            }


            if ((arguments[1].apiEndpoint)[apiEndpointLength - 1] === '/') {
                arguments[1].apiEndpoint = arguments[1].apiEndpoint.slice(0, -1);
            }
        }
    }

    // processing inputs
    if (arguments.length) {
        switch (arguments.length) {
            case 1:
                appData.trackingID = arguments[0];
                break;

            default:
                appData.trackingID = arguments[0];
                appData = utilHelper.merge(appData, arguments[1]);
                break;
        }
    } else {
        console.warn('Please provide credentials for accessing SDK.');
    }

    // schema validation
    schemaResult = tv4.validateMultiple(appData, appSchema, true);

    if (!schemaResult.valid) {
        if (appData.debugMode) {
            console.error((utilHelper.getErrorMessages(schemaResult.errors)).join(','));
            return;
        }

        sdkErrors.init = utilHelper.getErrorMessages(schemaResult.errors);
    }

    // Auto PageID Generation
    if (appData.AutotrackingID || typeof (appData.AutotrackingID) === 'undefined') {
        pageId = new PetPageId();
        pageId.autoPageId();
    }

    // merge app params with sdkparameters
    sdkParams = utilHelper.merge(appParams, appData);
    tracker = utilHelper.merge(self, new PetTracker(sdkParams, sdkErrors));

    return tracker;
};


/**
 * @module PETracker/events/telemetryMessage
 * @name PetTracker
 * @description It is a generic event to send Telemetry data
 */
/**
 * Sdk
 * @class PetTracker
 * @constructs PetTracker configurations and eventParameters
 */

PetTracker.prototype.startTelemetryInterval = function (timeFrequency) {
    var self = this;
    if (!this.telemetryInterval) {
        PetTracker.prototype.telemetryInterval = setInterval(function () {
            new PetOffline(self.sdkParams).isNetworkAvailable(true);
        }, 30000);
    }
};

PetTracker.prototype.eventDataformation = function (input) {
    if (!this.sdkParams.telemetryPageActivity) {
        this.sdkParams.telemetryPageActivity = {};
    }

    eventData = {}
    eventData.messageTypeCode = input.messageTypeCode || this.sdkParams.telemetryPageActivity.messageTypeCode || 'UserTelemetryPageActivity';
    if (input.messageVersion) {
        eventData.messageVersion = input.messageVersion;
    } else if (this.sdkParams.userTelemetryPageActivityMessageVersion) {
        eventData.messageVersion = this.sdkParams.userTelemetryPageActivityMessageVersion;
    } else {
        console.error('MessageVersion not Initialized')
    }

    eventData.actionType = 'create';
    eventData.namespace = arguments[0].namespaceCode || this.sdkParams.telemetryNamespace || 'Telemetry';
    eventData.payload = {};
    eventData.payload.messageTypeCode = arguments[0].messageTypeCode || this.sdkParams.messageTypeCode || this.sdkParams.telemetryPageActivity.messageTypeCode || 'UserTelemetryPageActivity';
    eventData.payload.originatingSystemCode = arguments[0].originatingSystemCode || this.sdkParams.originatingSystemCode || this.sdkParams.telemetryPageActivity.originatingSystemCode;
    eventData.payload.namespaceCode = arguments[0].namespaceCode || this.sdkParams.telemetryNamespace || this.sdkParams.telemetryPageActivity.telemetryNamespace || 'Telemetry';
    eventData.payload.messageVersion = eventData.messageVersion;
    eventData.payload.environmentCode = arguments[0].environmentCode || this.sdkParams.environment || this.sdkParams.telemetryPageActivity.environmentCode;
    eventData.payload.transactionDt = arguments[0].transactionDt || new Date().toISOString();
    eventData.payload.messageTransferType = arguments[0].messageTransferType || this.sdkParams.telemetryPageActivity.messageTransferType || 'LiveStream';
    eventData.payload.messageId = arguments[0].messageId || new PetUtilsHelper().getUuid();
    eventData.payload.personId = arguments[0].personId || this.sdkParams.telemetryPageActivity.personId || this.sdkParams.userID;
    eventData.payload.loginSessionId = arguments[0].loginSessionId || this.sdkParams.internalSessionID || this.sdkParams.telemetryPageActivity.loginSessionId || 'NA';
    eventData.payload.gaClientId = arguments[0].gaClientId || new PetUtilsHelper().getClientId() || this.sdkParams.telemetryPageAcitvity.gaClientId;
    eventData.payload.pageVisitId = window.PETPageID || this.sdkParams.telemetryPageActivity.PETPageID;
    eventData.payload.pageUrl = arguments[0].pageUrl || window.location.href || this.sdkParams.telemetryPageActivity.pageUrl;
    eventData.payload.userTelemetryPageErrors = [];
    eventData.payload.userTelemetryPageActions = [];
    this.sdkParams.telemetryPageActivity = eventData.payload;
    return eventData;
};

PetTracker.prototype.initTelemetry = function () {
    if (arguments[0]) {
        if (!window.PETPageID) {
            this.generatePageID();
        }

        var initTelemetry = {},
            initTelemetry;

        this.sdkParams.telemetryPageActivity = {};
        initTelemetry.telemetryData = {};
        initTelemetry.timeStamp = new Date().toISOString();
        initTelemetry.telemetryData.data = {};
        initTelemetry.telemetryData.data.originatingSystemCode = arguments[0].originatingSystemCode || this.sdkParams.originatingSystemCode;
        initTelemetry.telemetryData.data.events = [];
        eventData = this.eventDataformation(arguments[0], this.sdkParams);
        initTelemetry.telemetryData.data.events.push(eventData)
        telemetryData = JSON.parse(localStorage.getItem(this.telemetryStorage)) || {};
        telemetryData[petWindowObj.PETPageID] = initTelemetry;
        localStorage.setItem(this.telemetryStorage, JSON.stringify(telemetryData));
        if(!self.telemetryInterval){
            this.startTelemetryInterval();
        }       
    } else {
        console.error('Invalid arguments')
    }

}

PetTracker.prototype.saveTelemetryAction = function () {
    var flag = false,
        telemetryData = JSON.parse(localStorage.getItem(this.telemetryStorage)) || {},
        i;

    for (i in telemetryData) {
        if (i === window.PETPageID) {
            flag = true;
        }
    }

    if (!flag) {
        if (!window.PETPageID) {
            this.generatePageID();
        }

        initTelemetry = {};
        initTelemetry.telemetryData = {};
        initTelemetry.timeStamp = new Date().toISOString();
        initTelemetry.telemetryData.data = {};
        initTelemetry.telemetryData.data.originatingSystemCode = arguments[0].originatingSystemCode || this.sdkParams.originatingSystemCode;
        initTelemetry.telemetryData.data.events = [];
        eventData = this.eventDataformation({}, this.sdkParams);
        initTelemetry.telemetryData.data.events.push(eventData)
        telemetryData[window.PETPageID] = initTelemetry;
        localStorage.setItem(this.telemetryStorage, JSON.stringify(telemetryData));
        telemetryData = JSON.parse(localStorage.getItem(this.telemetryStorage));
    }

    switch (arguments[0]) {
        case 'event':
            telemetryData[window.PETPageID]['telemetryData']['data']['events'][0].payload.userTelemetryPageActions.push(arguments[1]);
            localStorage.setItem(this.telemetryStorage, JSON.stringify(telemetryData));
            break;
        case 'error':
            telemetryData[window.PETPageID]['telemetryData']['data']['events'][0].payload.userTelemetryPageErrors.push(arguments[1])
            localStorage.setItem(this.telemetryStorage, JSON.stringify(telemetryData));
            break;
        default:
            console.error('Invalid argument')
    }
    if(!self.telemetryInterval){
        this.startTelemetryInterval();
    }  

}


/**
 * @module PETracker/tracker
 * @name tracker
 * @description It is used to trigger the tracking events in Tracker SDK
 */
/**
 * Sdk
 * @class PetTracker
 * @constructs PETracker.sdkParams, PETracker.sdkErrors
 */
function PetTracker() {
    // parameter
    var generalParams = new PetGeneralParams().params,
        userParams = new PetUserParams().params,

        // custom modules
        utilHelper = new PetUtilsHelper();

    // Tracker Properties
    this.sdkParams = arguments[0];
    this.sdkErrors = arguments[1];
    this.telemetryStorage = 'telemetry';
    if(!this.telemetryInterval){
        this.startTelemetryInterval();
    }
    // merging general and user paramters into sdk parameters
    this.sdkParams = utilHelper.merge(this.sdkParams, utilHelper.merge(generalParams, userParams));
}

/** @function
 * @lends PETracker.prototype
 * @name setProperty
 * @description It is used to set the value to a Tracker parameters
 * @param {String} parameterName Parameter Name
 * @param {String} parameterValue Parameter Value
 * @returns {void} Null
 */
PetTracker.prototype.setProperty = function () {
    var paramName,
        paramValue,
        blocklist = ['clientID', 'trackingID'];

    if (arguments[0] && (typeof arguments[1] !== 'undefined')) {
        paramName = arguments[0];
        paramValue = arguments[1];

        // check the parameter name in the block list
        if (blocklist.indexOf(paramName) > -1) {
            console.warn('Cannot set the mandatory parameter: ' + paramName);
        } else if (paramName.indexOf('cd') === 0 || paramName.indexOf('cm') === 0) {

            // custom dimention and custom metrix check
            if (parseInt(paramName.substr(2)) <= 200 && parseInt(paramName.substr(2)) >= 1) {

                // Setting value
                this.sdkParams[paramName] = {
                    value: paramValue
                };

                // storing oldf data
                if (arguments[2]) {
                    this.sdkParams[paramName].paramName = arguments[2];
                }
            } else {
                console.warn('Please provide valid arguments.');
            }
        } else {
            this.sdkParams[paramName] = paramValue;
        }
    } else {
        console.warn('Provide valid arguments.');
    }
};

/** @function
 * @lends PETracker.prototype
 * @name getProperty
 * @description Returns the value of Tracker SDK Parameters
 * @param {String} parameterName Parameter Name
 * @returns {String/Undefined} parameterValue
 */
PetTracker.prototype.getProperty = function () {
    return this.sdkParams[arguments[0]];
};

/** @function
 * @lends PETracker.prototype
 * @name unsetProperty
 * @description It is used to reset or unset the value of Tracker SDK parameter
 * @param {String} parameterName Parameter Name
 * @returns {Void} void
 */
PetTracker.prototype.unsetProperty = function () {
    // local variables
    var paramName,

        // parameters list
        appParams = new PetAppParams().params,
        generalParams = new PetGeneralParams().params,

        // custom variables
        utilHelper = new PetUtilsHelper();

    // Check the parameter value
    if (arguments[0]) {
        paramName = arguments[0];
        if (this.sdkParams[paramName]) {
            if (paramName === 'userID') {
                this.sdkParams[paramName] = 'anonymous';
            } else if (paramName === 'environment') {
                this.sdkParams[paramName] = 'production';
            } else if (paramName in appParams) {
                console.warn('Cannot unset the mandatory parameters.');
            } else if (paramName in generalParams) {
                this.sdkParams[paramName] = generalParams[paramName];
            } else {
                delete this.sdkParams[paramName];
            }
        } else {
            console.warn('Given key is not a valid parameter.');
        }
    } else {
        console.error('Parameter cannot be null.');
    }
};

/** @function
 * @lends PETracker.prototype
 * @name getVersion
 * @description Returns Tracker SDK JS version
 * @returns {String} version
 */
PetTracker.prototype.getVersion = function () {
    return this.sdkParams.jsVersion;
};

/** @function
 * @lends PETracker.prototype
 * @name sendEvent
 * @description It is a generic method to send tracking data
 * @param {Object} Message Format
 * @returns {void} Null
 */
PetTracker.prototype.sendEvent = function () {
    /*
     * @member {Object}
     */
    var sdkEvent = new PetMessage(this.sdkParams);
    sdkEvent.track('events', arguments[0], arguments[1], arguments[2]);
};

/** @function
 * @lends PETracker.prototype
 * @name sendActivity
 * @description It is a generic method to send tracking data
 * @param {Object} Message Format
 * @returns {void} Null
 */
PetTracker.prototype.sendActivity = function () {
    /*
     * @member {Object}
     */
    var sdkEvent = new PetMessage(this.sdkParams);
    sdkEvent.track('activities', arguments[0], arguments[1], arguments[2]);
};

/** @function
 * @lends PETracker.prototype
 * @name whatsmyip
 * @description It fetches client's IP
 * @param {Function} callback function (err,ip)
 * @returns {void} Null
 */
PetTracker.prototype.getIP = function (callback) {
    if (typeof callback !== 'function') {
        return 'Callback must be a function';
    }

    var sdkEvent = new PetSDKIP(this.sdkParams);
    sdkEvent.getIP(callback);

    return null;
};

/** @function
 * @lends PETracker.prototype
 * @name getValueFromCookie
 * @description Returns the value from cookie
 * @param {String} cookieName Cookie Name
 * @param {String} indexName Key Name
 * @returns {String} value
 */
PetTracker.prototype.getValueFromCookie = function () {
    var cookieHelper = new PetCookie(),
        cookieData;

    if (arguments.length > 0) {
        // If the cookie have single value
        if (arguments.length === 1) {
            return cookieHelper.get(arguments[0]);
        } else if (arguments.length === 2) {
            try {
                cookieData = cookieHelper.get(arguments[0]);
                cookieData = JSON.parse(cookieData);
                return cookieData[arguments[1]];
            } catch (e) {
                console.error('Incorrect value specified in cookie: ' + arguments[0] + ' , ' + arguments[1]);
                return null;
            }
        } else {

            // Incorrect Arguments
            console.error('Incorrect arguments specified in cookie: ' + arguments);
            return null;
        }
    } else {
        console.error('Please, enter the cookie name');
        return null;
    }
};

/** @function
 * @lends PETracker.prototype
 * @name generatePageID
 * @description It is a method to Generate pageID manually
 * @returns {String} value
 */
PetTracker.prototype.generatePageID = function () {
    var PageId = new PetPageId();
    return PageId.generate();
}

/** @function
 * @lends PETracker.prototype
 * @name getPageID
 * @description It is a method to Get pageID manually
 * @returns {String} value
 */
PetTracker.prototype.getPageID = function () {
    var PageId = new PetPageId();
    return PageId.get();
}

})()
})()